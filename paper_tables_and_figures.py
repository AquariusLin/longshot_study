import matplotlib as mpl
mpl.use('Agg')
from matplotlib import pyplot as plt
import seaborn as sns
import pickle
import os
import gzip
import argparse
import numpy as np
import re
import statistics
from collections import namedtuple
from collections import defaultdict
import sys
import pysam
import pandas as pd
sys.path.append('HapCUT2/utilities')
import calculate_haplotype_statistics
import random
from analyze_variants import count_fp_near_true_indel

mpl.rc('legend', fontsize=9)
mpl.rc('xtick', labelsize=9)
mpl.rc('ytick', labelsize=9)
mpl.rc('axes', labelsize=9)
mpl.rc('axes', labelsize=9)
mpl.rcParams.update({'font.size': 9})
mpl.rc('lines', linewidth=1.5)
mpl.rc('mathtext',default='regular')

def parseargs():

    parser = argparse.ArgumentParser(description='this tool is meant to make precision-recall curves from RTGtools vcfeval data, that are prettier than those from RTGtools rocplot function.')
    parser.add_argument('-i', '--input_dirs', nargs='+', type = str, help='list of directories generated by RTGtools vcfeval tool', default=None)
    parser.add_argument('-l', '--labels', nargs='+', type = str, help='list of labels to associate to input_dirs', default=None)
    parser.add_argument('-o', '--output_file', nargs='?', type = str, help='PNG file to write plot to.', default=None)
    parser.add_argument('-t', '--title', nargs='?', type = str, help='title for plot', default=None)

    args = parser.parse_args()
    return args

def format_bp(basepairs):
    if basepairs / 1e9 > 1.0:
        return "{:.1f} Gb".format(basepairs / 1e9)
    elif basepairs / 1e6 > 1.0:
        return "{:.1f} Mb".format(basepairs / 1e6)
    elif basepairs / 1e3 > 1.0:
        return "{:.1f} kb".format(basepairs / 1e3)
    else:
        return "{} bp".format(int(basepairs))

def plot_vcfeval(dirlist, labels, output_file, title, colors=['r','#3333ff','#ccccff','#9999ff','#8080ff','#6666ff'], xlim=(0.6,1.0), ylim=(0.95,1.0), legendloc='lower left'):


    # add a small amount of padding to the xlim and ylim so that grid lines show up on the borders
    xpad = (xlim[1] - xlim[0])/100
    ypad = (ylim[1] - ylim[0])/100
    xlim = (xlim[0]-xpad, xlim[1]+xpad)
    ylim = (ylim[0]-ypad, ylim[1]+ypad)

    plt.figure();
    ax1 = plt.subplot(111)
    if title != None:
        plt.title(title)

    if len(dirlist) > len(colors):
        print("need to define larger color pallet to plot this many datasets.")
        exit(1)

    for color, path, label in zip(colors, dirlist,labels):

        #quals = []
        recalls = []
        precisions = []

        with gzip.open(os.path.join(path,'snp_roc.tsv.gz'),mode='rt') as inf:

            for line in inf:
                if line[0] == '#':
                    continue
                else:
                    el = [float(x) for x in line.strip().split()]
                    assert(len(el) == 8)
                    #quals.append(el[0])
                    precisions.append(el[5])
                    recalls.append(el[6])

        plt.plot(recalls, precisions, color=color,label=label,linewidth=3,alpha=0.75)

    plt.grid(True,color='grey',linestyle='--',alpha=0.5)

    ax1.spines["top"].set_visible(False)
    ax1.spines["right"].set_visible(False)
    ax1.spines["bottom"].set_visible(False)
    ax1.spines["left"].set_visible(False)
    plt.tick_params(axis="both", which="both", bottom="off", top="off",
                labelbottom="on", left="off", right="off", labelleft="on")

    plt.xlim(xlim)
    plt.ylim(ylim)
    plt.xlabel('Recall')
    plt.ylabel('Precision')
    plt.legend(loc=legendloc)
    plt.tight_layout()
    ax1.set_axisbelow(True)
    plt.savefig(output_file)


# input:
# vcfeval_dir: directory containing vcfeval output
# gq_cutoff: a Genotype Quality value to set as the cutoff for variants e.g. 30 or 50
# output:
# (precision, recall) : the precision and recall values for variants above the GQ cutoff
def get_precision_recall(vcfeval_dir, gq_cutoff):

    recall = None
    precision = None
    qual = None

    with gzip.open(os.path.join(vcfeval_dir,'snp_roc.tsv.gz'),mode='rt') as inf:

        for line in inf:
            if line[0] == '#':
                continue
            else:
                el = [float(x) for x in line.strip().split()]
                assert(len(el) == 8)
                new_qual = el[0]
                if new_qual < gq_cutoff:
                    break

                qual = new_qual
                precision = el[5]
                recall = el[6]

    # this should be true for large enough datasets, like we will look at,
    # and it's a nice sanity check
    assert(qual - gq_cutoff >= 0)
    assert(qual - gq_cutoff < 1.0)
    assert(precision != None)
    assert(recall != None)

    return (precision, recall)

def plot_precision_recall_bars_simulation(pacbio_dirlist_genome, illumina_dirlist_genome, pacbio_dirlist_segdup, illumina_dirlist_segdup, gq_cutoff, labels, output_file):

    plt.figure(figsize=(7,5))
    #mpl.rcParams['axes.titlepad'] = 50

    width = 0.15
    alpha1 = 0.6


    def make_subplot(ax, ind, pacbio_vals, illumina_vals, lab_pacbio=None, lab_illumina=None, fc='#ffffff'):

        plt.bar(ind+width, pacbio_vals, color='#2200ff',
                ecolor='black', # black error bar color
                alpha=alpha1,      # transparency
                width=width,      # smaller bar width
                align='center',
                label=lab_pacbio,
                zorder=0)
        plt.bar(ind+2*width, illumina_vals, color='#ff1900',
                ecolor='black', # black error bar color
                alpha=alpha1,      # transparency
                width=width,      # smaller bar width
                align='center',
                label=lab_illumina,
                zorder=0)
        # add some text for labels, title and axes ticks
        #plt.xlim(-0.5,6)


    def prettify_plot():

        ax.yaxis.grid(True,color='grey', alpha=0.5, linestyle='--',zorder=1.0)
        ax.spines["top"].set_visible(False)
        ax.spines["right"].set_visible(False)
        ax.spines["bottom"].set_visible(False)
        ax.spines["left"].set_visible(False)
        plt.tick_params(axis="both", which="both", bottom=False, top=False,
                    labelbottom=True, left=False, right=False, labelleft=True)


    ind1 = [0,0.5,1,1.5]
    ind2 = [2.25,2.75,3.25,3.75]
    ind = ind1 + ind2

    pacbio_precisions_genome, pacbio_recalls_genome = zip(*[get_precision_recall(d, gq_cutoff) for d in pacbio_dirlist_genome])
    illumina_precisions_genome, illumina_recalls_genome = zip(*[get_precision_recall(d, gq_cutoff) for d in illumina_dirlist_genome])
    pacbio_precisions_segdup, pacbio_recalls_segdup = zip(*[get_precision_recall(d, gq_cutoff) for d in pacbio_dirlist_segdup])
    illumina_precisions_segdup, illumina_recalls_segdup = zip(*[get_precision_recall(d, gq_cutoff) for d in illumina_dirlist_segdup])

    ax = plt.subplot(211)
    make_subplot(ax,np.array(ind1), pacbio_precisions_genome, illumina_precisions_genome, lab_pacbio='PacBio + Reaper', lab_illumina='Illumina + Freebayes',fc='#e0e1e2')
    make_subplot(ax, np.array(ind2), pacbio_precisions_segdup, illumina_precisions_segdup,fc='#dddddd')
    ax.legend(loc='center left', bbox_to_anchor=(0.25,1.13),ncol=2)

    plt.ylabel("Precision")
    plt.ylim(0.99,1.0)
    prettify_plot()
    ax.set_xticks([])
    ax.set_xticklabels([])

    ax = plt.subplot(212)
    plt.ylabel("Recall\n")
    plt.ylim(0.0-0.001,1.001)
    make_subplot(ax, np.array(ind1), pacbio_recalls_genome, illumina_recalls_genome,fc='#e0e1e2')
    make_subplot(ax, np.array(ind2), pacbio_recalls_segdup, illumina_recalls_segdup,fc='#dddddd')
    prettify_plot()
    ax.set_xticks(np.array(ind)+1.5*width)
    ax.set_xticklabels(labels+labels)

    #ax.set_yscale('log')NA12878_prec_recall_{chrom}
    #plt.xlim(())
    #plt.ylim((0,1.0))
    #plt.legend(loc='upper left')
    plt.xlabel(" ",labelpad=10)

    plt.tight_layout()
    plt.subplots_adjust(top=0.90)
    #t = plt.suptitle(title)

    ax.set_axisbelow(True)

    ticklabelpad = mpl.rcParams['xtick.major.pad']

    ax.annotate('coverage', xy=(-0.1,-0.03), xytext=(5, -ticklabelpad), ha='left', va='top',
                xycoords='axes fraction', textcoords='offset points')
    ax.annotate('Whole Genome', xy=(0.16,-0.15), xytext=(5, -ticklabelpad), ha='left', va='top',
                xycoords='axes fraction', textcoords='offset points')
    ax.annotate('Segmental Duplications Only', xy=(0.58,-0.15), xytext=(5, -ticklabelpad), ha='left', va='top',
                xycoords='axes fraction', textcoords='offset points')

    # credit to https://stackoverflow.com/questions/4700614/how-to-put-the-legend-out-of-the-plot
    # Shrink current axis by 20%
    box = ax.get_position()
    #ax.set_position([box.x0, box.y0, box.width * 0.85, box.height])
    # Put a legend to the right of the current axis
    #ax.legend(loc='center left', bbox_to_anchor=(1, 0.5))

    #plt.show()
    plt.savefig(output_file)

def plot_precision_recall_bars_simulation_extended(pacbio_ngmlr_dirlist_genome,
                                                      pacbio_minimap2_dirlist_genome,
                                                      pacbio_bwamem_dirlist_genome,
                                                      pacbio_blasr_dirlist_genome,
                                                      illumina_dirlist_genome,
                                                      pacbio_ngmlr_dirlist_segdup,
                                                      pacbio_minimap2_dirlist_segdup,
                                                      pacbio_bwamem_dirlist_segdup,
                                                      pacbio_blasr_dirlist_segdup,
                                                      illumina_dirlist_segdup,
                                                      gq_cutoff, labels, output_file):

    plt.figure(figsize=(7,5))
    #mpl.rcParams['axes.titlepad'] = 50

    width = 0.075
    alpha1 = 0.6

    def make_subplot(ax,
                     ind,
                     pacbio_ngmlr_vals,
                     pacbio_minimap2_vals,
                     pacbio_bwamem_vals,
                     pacbio_blasr_vals,
                     illumina_vals,
                     lab_pacbio_ngmlr=None,
                     lab_pacbio_minimap2=None,
                     lab_pacbio_bwamem=None,
                     lab_pacbio_blasr=None,
                     lab_illumina=None):

        plt.bar(ind+width, pacbio_ngmlr_vals, color='#ffe500',
                ecolor='black',
                alpha=alpha1,      # transparency
                width=width,      # smaller bar width
                align='center',
                label=lab_pacbio_ngmlr,
                zorder=0)
        plt.bar(ind+2*width, pacbio_minimap2_vals, color='#00ff33',
                ecolor='black',
                alpha=alpha1,      # transparency
                width=width,      # smaller bar width
                align='center',
                label=lab_pacbio_minimap2,
                zorder=0)
        plt.bar(ind+3*width, pacbio_bwamem_vals, color='#ff0094',
                ecolor='black',
                alpha=alpha1,      # transparency
                width=width,      # smaller bar width
                align='center',
                label=lab_pacbio_bwamem,
                zorder=0)
        plt.bar(ind+4*width, pacbio_blasr_vals, color='#2200ff',
                ecolor='black',
                alpha=alpha1,      # transparency
                width=width,      # smaller bar width
                align='center',
                label=lab_pacbio_blasr,
                zorder=0)
        plt.bar(ind+5*width, illumina_vals, color='#ff1900',
                ecolor='black',
                alpha=alpha1,      # transparency
                width=width,      # smaller bar width
                align='center',
                label=lab_illumina,
                zorder=0)
        # add some text for labels, title and axes ticks
        #plt.xlim(-0.5,6)


    def prettify_plot(ax):

        ax.yaxis.grid(True,color='grey', linestyle='--', alpha=0.5, zorder=1.0)
        ax.spines["top"].set_visible(False)
        ax.spines["right"].set_visible(False)
        ax.spines["bottom"].set_visible(False)
        ax.spines["left"].set_visible(False)
        plt.tick_params(axis="both", which="both", bottom=False, top=False,
                    labelbottom=True, left=False, right=False, labelleft=True)


    ind1 = [0,0.5,1,1.5]
    ind2 = [2.25,2.75,3.25,3.75]
    ind = ind1 + ind2

    pacbio_ngmlr_precisions_genome, pacbio_ngmlr_recalls_genome = zip(*[get_precision_recall(d, gq_cutoff) for d in pacbio_ngmlr_dirlist_genome])
    pacbio_minimap2_precisions_genome, pacbio_minimap2_recalls_genome = zip(*[get_precision_recall(d, gq_cutoff) for d in pacbio_minimap2_dirlist_genome])
    pacbio_bwamem_precisions_genome, pacbio_bwamem_recalls_genome = zip(*[get_precision_recall(d, gq_cutoff) for d in pacbio_bwamem_dirlist_genome])
    pacbio_blasr_precisions_genome, pacbio_blasr_recalls_genome = zip(*[get_precision_recall(d, gq_cutoff) for d in pacbio_blasr_dirlist_genome])
    illumina_precisions_genome, illumina_recalls_genome = zip(*[get_precision_recall(d, gq_cutoff) for d in illumina_dirlist_genome])

    pacbio_ngmlr_precisions_segdup, pacbio_ngmlr_recalls_segdup = zip(*[get_precision_recall(d, gq_cutoff) for d in pacbio_ngmlr_dirlist_segdup])
    pacbio_minimap2_precisions_segdup, pacbio_minimap2_recalls_segdup = zip(*[get_precision_recall(d, gq_cutoff) for d in pacbio_minimap2_dirlist_segdup])
    pacbio_bwamem_precisions_segdup, pacbio_bwamem_recalls_segdup = zip(*[get_precision_recall(d, gq_cutoff) for d in pacbio_bwamem_dirlist_segdup])
    pacbio_blasr_precisions_segdup, pacbio_blasr_recalls_segdup = zip(*[get_precision_recall(d, gq_cutoff) for d in pacbio_blasr_dirlist_segdup])
    illumina_precisions_segdup, illumina_recalls_segdup = zip(*[get_precision_recall(d, gq_cutoff) for d in illumina_dirlist_segdup])

    ax1 = plt.subplot(211)
    make_subplot(ax=ax1,
                ind=np.array(ind1),
                pacbio_ngmlr_vals=pacbio_ngmlr_precisions_genome,
                pacbio_minimap2_vals=pacbio_minimap2_precisions_genome,
                pacbio_bwamem_vals=pacbio_bwamem_precisions_genome,
                pacbio_blasr_vals=pacbio_blasr_precisions_genome,
                illumina_vals=illumina_precisions_genome,
                lab_pacbio_ngmlr='PacBio + NGMLR + Reaper',
                lab_pacbio_minimap2='PacBio + Minimap2 + Reaper',
                lab_pacbio_bwamem='PacBio + BWA-MEM + Reaper',
                lab_pacbio_blasr='PacBio + BLASR + Reaper',
                lab_illumina='Illumina + Freebayes')

    make_subplot(ax=ax1,
                ind=np.array(ind2),
                pacbio_ngmlr_vals=pacbio_ngmlr_precisions_segdup,
                pacbio_minimap2_vals=pacbio_minimap2_precisions_segdup,
                pacbio_bwamem_vals=pacbio_bwamem_precisions_segdup,
                pacbio_blasr_vals=pacbio_blasr_precisions_segdup,
                illumina_vals=illumina_precisions_segdup)

    ax1.legend(loc='center left', bbox_to_anchor=(0.1,1.25),ncol=2)

    plt.ylabel("Precision")
    plt.ylim(0.96,1.0)
    ax1.set_xticks([])
    ax1.set_xticklabels([])

    prettify_plot(ax1)
    ax2 = plt.subplot(212)
    plt.ylabel("Recall\n")
    plt.ylim(0.0-0.001,1.001)

    make_subplot(ax=ax2,
                ind=np.array(ind1),
                pacbio_ngmlr_vals=pacbio_ngmlr_recalls_genome,
                pacbio_minimap2_vals=pacbio_minimap2_recalls_genome,
                pacbio_bwamem_vals=pacbio_bwamem_recalls_genome,
                pacbio_blasr_vals=pacbio_blasr_recalls_genome,
                illumina_vals=illumina_recalls_genome)

    make_subplot(ax=ax2,
                ind=np.array(ind2),
                pacbio_ngmlr_vals=pacbio_ngmlr_recalls_segdup,
                pacbio_minimap2_vals=pacbio_minimap2_recalls_segdup,
                pacbio_bwamem_vals=pacbio_bwamem_recalls_segdup,
                pacbio_blasr_vals=pacbio_blasr_recalls_segdup,
                illumina_vals=illumina_recalls_segdup)

    ax2.set_xticks(np.array(ind)+3*width)
    ax2.set_xticklabels(labels+labels)

    #ax.set_yscale('log')NA12878_prec_recall_{chrom}
    #plt.xlim(())
    #plt.ylim((0,1.0))
    #plt.legend(loc='upper left')
    plt.xlabel(" ",labelpad=10)

    plt.tight_layout()
    plt.subplots_adjust(top=0.82)
    #t = plt.suptitle(title)

    ax2.set_axisbelow(True)

    ticklabelpad = mpl.rcParams['xtick.major.pad']

    ax2.annotate('coverage', xy=(-0.1,-0.03), xytext=(5, -ticklabelpad), ha='left', va='top',
                xycoords='axes fraction', textcoords='offset points')
    ax2.annotate('Whole Genome', xy=(0.16,-0.15), xytext=(5, -ticklabelpad), ha='left', va='top',
                xycoords='axes fraction', textcoords='offset points')
    ax2.annotate('Segmental Duplications Only', xy=(0.58,-0.15), xytext=(5, -ticklabelpad), ha='left', va='top',
                xycoords='axes fraction', textcoords='offset points')
    prettify_plot(ax2)

    # credit to https://stackoverflow.com/questions/4700614/how-to-put-the-legend-out-of-the-plot
    # Shrink current axis by 20%
    #box = ax2.get_position()
    #ax.set_position([box.x0, box.y0, box.width * 0.85, box.height])
    # Put a legend to the right of the current axis
    #ax.legend(loc='center left', bbox_to_anchor=(1, 0.5))

    #plt.show()
    plt.savefig(output_file)


def plot_haplotyping_results(reaper_errs, hapcut2_errs, output_file):
    # errs should be in order: NA12878 44x, NA24385 69x
    assert(len(reaper_errs) == 2)
    assert(len(hapcut2_errs) == 2)

    #unpickle the error objects
    reaper_errs = [pickle.load(open(f,'rb')) for f in reaper_errs]
    hapcut2_errs = [pickle.load(open(f,'rb')) for f in hapcut2_errs]

    plt.figure(figsize=(6,6))
    #mpl.rcParams['axes.titlepad'] = 50

    width = 0.15
    alpha1 = 0.6


    def make_subplot(ax, ind, reaper_vals, hapcut2_vals, lab_reaper=None, lab_hapcut2=None):

        plt.bar(ind+width, reaper_vals, color='#2200ff',
                ecolor='black', # black error bar color
                alpha=alpha1,      # transparency
                width=width,      # smaller bar width
                align='center',
                label=lab_reaper,
                zorder=0)
        plt.bar(ind+2*width, hapcut2_vals, color='k',
                ecolor='black', # black error bar color
                alpha=alpha1,      # transparency
                width=width,      # smaller bar width
                align='center',
                label=lab_hapcut2,
                zorder=0)
        # add some text for labels, title and axes ticks
        #plt.xlim(-0.5,6)


    def prettify_plot():

        ax.yaxis.grid(True,color='grey', alpha=0.5, linestyle='--',zorder=1.0)
        ax.spines["top"].set_visible(False)
        ax.spines["right"].set_visible(False)
        ax.spines["bottom"].set_visible(False)
        ax.spines["left"].set_visible(False)
        plt.tick_params(axis="both", which="both", bottom=False, top=False,
                    labelbottom=True, left=False, right=False, labelleft=True)


    ind = [0,0.4]

    ax = plt.subplot(211)
    reaper_switch_mismatch = [e.get_switch_mismatch_rate() for e in reaper_errs]
    hapcut2_switch_mismatch = [e.get_switch_mismatch_rate() for e in hapcut2_errs]
    make_subplot(ax,np.array(ind), reaper_switch_mismatch, hapcut2_switch_mismatch, lab_reaper='Reaper Haplotype', lab_hapcut2='30x Illumina + HapCUT2 Haplotype')
    ax.legend(loc='center left', bbox_to_anchor=(0.0,1.13),ncol=2)

    plt.ylabel("Switch + Mismatch Error Rate")
    #plt.ylim(0.99,1.0)
    prettify_plot()
    ax.set_xticks([])
    ax.set_xticklabels([])

    ax = plt.subplot(212)
    plt.ylabel("N50\n")
    reaper_N50 = [e.get_N50() for e in reaper_errs]
    hapcut2_N50 = [e.get_N50() for e in hapcut2_errs]
    make_subplot(ax,np.array(ind), reaper_N50, hapcut2_N50)
    prettify_plot()
    ax.set_xticks(np.array(ind)+1.5*width)
    ax.set_xticklabels(['NA12878\n44x','NA24385\n69x'])

    #ax.set_yscale('log')NA12878_prec_recall_{chrom}
    #plt.xlim(())
    #plt.ylim((0,1.0))
    #plt.legend(loc='upper left')
    plt.xlabel(" ",labelpad=10)

    plt.tight_layout()
    plt.subplots_adjust(top=0.90)
    #t = plt.suptitle(title)

    ax.set_axisbelow(True)

    ticklabelpad = mpl.rcParams['xtick.major.pad']

    # credit to https://stackoverflow.com/questions/4700614/how-to-put-the-legend-out-of-the-plot
    # Shrink current axis by 20%
    box = ax.get_position()
    #ax.set_position([box.x0, box.y0, box.width * 0.85, box.height])
    # Put a legend to the right of the current axis
    #ax.legend(loc='center left', bbox_to_anchor=(1, 0.5))

    #plt.show()
    plt.savefig(output_file)


def plot_precision_recall_bars_NA12878_NA24385(pacbio_dirlist_NA24385, illumina_dirlist_NA24385,
                                               pacbio_dirlist_NA12878, illumina_dirlist_NA12878,
                                               gq_cutoffs_NA24385, gq_cutoffs_NA12878,
                                               gq_cutoff_illumina, output_file):

    plt.figure(figsize=(7,5))
    #mpl.rcParams['axes.titlepad'] = 50

    width = 0.135
    alpha1 = 0.6

    def plot_bars(ax, ind, vals, color=None, lab=None):

        plt.bar(ind+width, vals, color=color,
                ecolor='black', # black error bar color
                alpha=alpha1,      # transparency
                width=width,      # smaller bar width
                align='center',
                label=lab,
                zorder=0)

    def prettify_plot():

        ax.yaxis.grid(True,color='grey', alpha=0.5, linestyle='--',zorder=1.0)
        ax.spines["top"].set_visible(False)
        ax.spines["right"].set_visible(False)
        ax.spines["bottom"].set_visible(False)
        ax.spines["left"].set_visible(False)
        plt.tick_params(axis="both", which="both", bottom=False, top=False,
                    labelbottom=True, left=False, right=False, labelleft=True)


    #ind1 = [0,0.15,0.3,0.45,0.6]
    #ind2 = [0.75]
    #ind3 = [1.05,1.2]
    #ind4 = [1.35]

    ind1 = [0,0.15,0.3,0.45]
    ind2 = [0.6]
    ind3 = [0.9,1.05]
    ind4 = [1.2]


    pacbio_precisions_NA24385, pacbio_recalls_NA24385 = zip(*[get_precision_recall(d, g) for d,g in zip(pacbio_dirlist_NA24385, gq_cutoffs_NA24385)])
    #truncate because we no longer want to plot 69x
    pacbio_precisions_NA24385 = pacbio_precisions_NA24385[:-1]
    pacbio_recalls_NA24385 = pacbio_recalls_NA24385[:-1]
    illumina_precisions_NA24385, illumina_recalls_NA24385 = zip(*[get_precision_recall(d, gq_cutoff_illumina) for d in illumina_dirlist_NA24385])
    pacbio_precisions_NA12878, pacbio_recalls_NA12878 = zip(*[get_precision_recall(d, g) for d,g in zip(pacbio_dirlist_NA12878, gq_cutoffs_NA12878)])
    illumina_precisions_NA12878, illumina_recalls_NA12878 = zip(*[get_precision_recall(d, gq_cutoff_illumina) for d in illumina_dirlist_NA12878])

    ax = plt.subplot(211)
    plot_bars(ax, np.array(ind1), pacbio_precisions_NA24385,color='#2200ff',lab='PacBio SMRT')
    plot_bars(ax, np.array(ind2), illumina_precisions_NA24385,color='#ff1900',lab='Illumina')
    plot_bars(ax, np.array(ind3), pacbio_precisions_NA12878,color='#2200ff')
    plot_bars(ax, np.array(ind4), illumina_precisions_NA12878,color='#ff1900')
    ax.legend(loc='center left', bbox_to_anchor=(0.25,1.13),ncol=2)

    plt.ylabel("Precision")
    plt.ylim(0.9,1.0)
    prettify_plot()
    ax.set_xticks([])
    ax.set_xticklabels([])

    ax = plt.subplot(212)
    plt.ylabel("Recall\n")
    plot_bars(ax, np.array(ind1), pacbio_recalls_NA24385,color='#2200ff')
    plot_bars(ax, np.array(ind2), illumina_recalls_NA24385,color='#ff1900')
    plot_bars(ax, np.array(ind3), pacbio_recalls_NA12878,color='#2200ff')
    plot_bars(ax, np.array(ind4), illumina_recalls_NA12878,color='#ff1900')
    prettify_plot()
    ax.set_xticks(np.array(ind1+ind2+ind3+ind4)+1.0*width)
    ax.set_xticklabels(['20','30','40','50','30','30','44','30'])

    #ax.set_yscale('log')NA12878_prec_recall_{chrom}
    #plt.xlim(())
    #plt.ylim((0,1.0))
    #plt.legend(loc='upper left')
    plt.xlabel(" ",labelpad=10)

    plt.tight_layout()
    plt.subplots_adjust(top=0.90)
    #t = plt.suptitle(title)

    ax.set_axisbelow(True)

    ticklabelpad = mpl.rcParams['xtick.major.pad']

    ax.annotate('coverage', xy=(-0.1,-0.03), xytext=(5, -ticklabelpad), ha='left', va='top',
                xycoords='axes fraction', textcoords='offset points')
    ax.annotate('NA24385', xy=(0.27,-0.15), xytext=(5, -ticklabelpad), ha='left', va='top',
                xycoords='axes fraction', textcoords='offset points')
    ax.annotate('NA12878', xy=(0.77,-0.15), xytext=(5, -ticklabelpad), ha='left', va='top',
                xycoords='axes fraction', textcoords='offset points')

    # credit to https://stackoverflow.com/questions/4700614/how-to-put-the-legend-out-of-the-plot
    # Shrink current axis by 20%
    box = ax.get_position()
    #ax.set_position([box.x0, box.y0, box.width * 0.85, box.height])
    # Put a legend to the right of the current axis
    #ax.legend(loc='center left', bbox_to_anchor=(1, 0.5))

    #plt.show()
    plt.savefig(output_file)




def plot_precision_recall_bars_NA12878_NA24385_with_haplotypefree(hap_dirlist_NA24385, nohap_dirlist_NA24385,
                                               hap_dirlist_NA12878, nohap_dirlist_NA12878,
                                               gq_cutoffs_NA24385, gq_cutoffs_NA12878, output_file):

    plt.figure(figsize=(7,5))
    #mpl.rcParams['axes.titlepad'] = 50

    width = 0.05
    alpha1 = 0.6

    def plot_bars(ax, ind, vals1, vals2, lab1=None, lab2=None):

        plt.bar(ind+width, vals1, color='#2200ff',
                ecolor='black', # black error bar color
                alpha=alpha1,      # transparency
                width=width,      # smaller bar width
                align='center',
                label=lab1)
        plt.bar(ind+2*width, vals2, color='k',
                ecolor='black', # black error bar color
                alpha=alpha1,      # transparency
                width=width,      # smaller bar width
                align='center',
                label=lab2)

    def prettify_plot():

        ax.yaxis.grid(True,color='grey', alpha=0.5, linestyle='--')
        ax.spines["top"].set_visible(False)
        ax.spines["right"].set_visible(False)
        ax.spines["bottom"].set_visible(False)
        ax.spines["left"].set_visible(False)
        plt.tick_params(axis="both", which="both", bottom=False, top=False,
                    labelbottom=True, left=False, right=False, labelleft=True)


    ind1 = [0,0.15,0.3,0.45,0.6]
    ind2 = [0.9,1.05]

    hap_precisions_NA24385, hap_recalls_NA24385 = zip(*[get_precision_recall(d, g) for d,g in zip(hap_dirlist_NA24385, gq_cutoffs_NA24385)])
    nohap_precisions_NA24385, nohap_recalls_NA24385 = zip(*[get_precision_recall(d, g) for d,g in zip(nohap_dirlist_NA24385, gq_cutoffs_NA24385)])
    hap_precisions_NA12878, hap_recalls_NA12878 = zip(*[get_precision_recall(d, g) for d,g in zip(hap_dirlist_NA12878,gq_cutoffs_NA12878)])
    nohap_precisions_NA12878, nohap_recalls_NA12878 = zip(*[get_precision_recall(d, g) for d,g in zip(nohap_dirlist_NA12878,gq_cutoffs_NA12878)])

    ax = plt.subplot(211)
    plot_bars(ax, np.array(ind1), hap_precisions_NA24385, nohap_precisions_NA24385, lab1='With haplotype assembly', lab2='Without haplotype assembly')
    plot_bars(ax, np.array(ind2), hap_precisions_NA12878, nohap_precisions_NA12878)
    ax.legend(loc='center left', bbox_to_anchor=(0.25,1.13),ncol=2)

    plt.ylabel("Precision")
    plt.ylim(0.95,1.0)
    prettify_plot()
    ax.set_xticks([])
    ax.set_xticklabels([])

    ax = plt.subplot(212)
    plt.ylabel("Recall\n")
    plot_bars(ax, np.array(ind1), hap_recalls_NA24385, nohap_recalls_NA24385, lab1='With haplotype assembly', lab2='Without haplotype assembly')
    plot_bars(ax, np.array(ind2), hap_recalls_NA12878, nohap_recalls_NA12878)
    prettify_plot()
    ax.set_xticks(np.array(ind1+ind2)+1.5*width)
    ax.set_xticklabels(['20','30','40','50','69','30','44'])

    #ax.set_yscale('log')NA12878_prec_recall_{chrom}
    #plt.xlim(())
    #plt.ylim((0,1.0))
    #plt.legend(loc='upper left')
    plt.xlabel(" ",labelpad=10)

    plt.tight_layout()
    plt.subplots_adjust(top=0.90)
    #t = plt.suptitle(title)

    ax.set_axisbelow(True)

    ticklabelpad = mpl.rcParams['xtick.major.pad']

    ax.annotate('coverage', xy=(-0.1,-0.03), xytext=(5, -ticklabelpad), ha='left', va='top',
                xycoords='axes fraction', textcoords='offset points')
    ax.annotate('NA24385', xy=(0.23,-0.15), xytext=(5, -ticklabelpad), ha='left', va='top',
                xycoords='axes fraction', textcoords='offset points')
    ax.annotate('NA12878', xy=(0.7,-0.15), xytext=(5, -ticklabelpad), ha='left', va='top',
                xycoords='axes fraction', textcoords='offset points')

    # credit to https://stackoverflow.com/questions/4700614/how-to-put-the-legend-out-of-the-plot
    # Shrink current axis by 20%
    box = ax.get_position()
    #ax.set_position([box.x0, box.y0, box.width * 0.85, box.height])
    # Put a legend to the right of the current axis
    #ax.legend(loc='center left', bbox_to_anchor=(1, 0.5))

    #plt.show()
    plt.savefig(output_file)



genomes_table_files = namedtuple('genomes_table_files', ['vcfeval_dir', 'vcfstats_genome', 'vcfstats_outside_GIAB', 'runtime'])
genomes_table_entry = namedtuple('genomes_table_entry', ['SNVs_called', 'precision', 'recall', 'outside_GIAB', 'runtime'])

def get_snp_count(vcfstats_file):
    passed_re = re.compile("\nPassed Filters\s+: (\d+)\n")
    snps_re = re.compile("\nSNPs\s+: (-|\d+)\n")
    with open(vcfstats_file,'r') as inf:
        fstr = inf.read()
        if int(passed_re.findall(fstr)[0]) == 0:
            return 0
        else:
            return int(snps_re.findall(fstr)[0])

def get_TsTv(vcfstats_file):
    tstv_re = re.compile("\nSNP Transitions/Transversions: (-|\d+\.\d+)\s+")
    with open(vcfstats_file,'r') as inf:
        fstr = inf.read()
        res = tstv_re.findall(fstr)[0]
        if res == '-':
            return 0.0
        else:
            return float(res)

def make_table_4_genomes(NA12878_table_files, NA24385_table_files,
                         NA24149_table_files, NA24143_table_files,
                         gq_cutoffs, outfile):

    def generate_table_line(table_files, gq_cutoff):

        precision, recall = get_precision_recall(table_files.vcfeval_dir, gq_cutoff)
        with open(table_files.runtime,'r') as inf:
            hh, mm, ss = inf.readline().strip().split(':')
        runtime = hh + ':' + mm

        snvs_total = get_snp_count(table_files.vcfstats_genome)
        snvs_outside_giab = get_snp_count(table_files.vcfstats_outside_GIAB)

        return genomes_table_entry(SNVs_called=snvs_total, precision=precision, recall=recall,
                                   outside_GIAB=snvs_outside_giab, runtime=runtime)

    NA12878 = generate_table_line(NA12878_table_files, gq_cutoffs[0])
    NA24385 = generate_table_line(NA24385_table_files, gq_cutoffs[1])
    NA24149 = generate_table_line(NA24149_table_files, gq_cutoffs[2])
    NA24143 = generate_table_line(NA24143_table_files, gq_cutoffs[3])

    s = '''
\\begin{{table}}[htbp]
\\centering
\\begin{{tabular}}{{lllllll}}
\\hline
Genome      & Read & SNVs    & Precision     & Recall    & Outside GIAB  & Run time  \\\\
            & Coverage & called    &    &  & high-confidence       & (hours)          \\\\
\\hline
NA12878   & $44\\times$ & ${}$ & ${:.3f}$ & ${:.3f}$ & ${}$ & {} \\\\
NA24385 (AJ son) & $69\\times$ & ${}$ & ${:.3f}$ & ${:.3f}$ & ${}$ & {} \\\\
NA24149 (AJ father) & $32\\times$ & ${}$ & ${:.3f}$ & ${:.3f}$ & ${}$ & {} \\\\
NA24143 (AJ mother) & $30\\times$ & ${}$ & ${:.3f}$ & ${:.3f}$ & ${}$ & {} \\\\
# \\hline
\\end{{tabular}}
\\caption{{{{\\bf Summary of variants called on GIAB genomes.}}}}
\\label{{tab:stats}}
\\end{{table}}
'''.format(NA12878.SNVs_called, NA12878.precision, NA12878.recall, NA12878.outside_GIAB, NA12878.runtime,
           NA24385.SNVs_called, NA24385.precision, NA24385.recall, NA24385.outside_GIAB, NA24385.runtime,
           NA24149.SNVs_called, NA24149.precision, NA24149.recall, NA24149.outside_GIAB, NA24149.runtime,
           NA24143.SNVs_called, NA24143.precision, NA24143.recall, NA24143.outside_GIAB, NA24143.runtime)

    with open(outfile,'w') as outf:
        print(s, file=outf)

def make_table_4_genomes_extended(NA12878_30x_table_files, NA12878_44x_table_files,
                                  NA24385_20x_table_files, NA24385_30x_table_files,
                                  NA24385_40x_table_files, NA24385_50x_table_files,
                                  NA24385_69x_table_files,
                                  NA24149_32x_table_files,
                                  NA24143_30x_table_files,
                                  gq_cutoffs, outfile):

    def generate_table_line(table_files, gq_cutoff):

        precision, recall = get_precision_recall(table_files.vcfeval_dir, gq_cutoff)
        with open(table_files.runtime,'r') as inf:
            hh, mm, ss = inf.readline().strip().split(':')
        runtime = hh + ':' + mm

        snvs_total = get_snp_count(table_files.vcfstats_genome)
        snvs_outside_giab = get_snp_count(table_files.vcfstats_outside_GIAB)

        return genomes_table_entry(SNVs_called=snvs_total, precision=precision, recall=recall,
                                   outside_GIAB=snvs_outside_giab, runtime=runtime)

    NA12878_30x = generate_table_line(NA12878_30x_table_files, gq_cutoffs[0])
    NA12878_44x = generate_table_line(NA12878_44x_table_files, gq_cutoffs[1])

    NA24385_20x = generate_table_line(NA24385_20x_table_files, gq_cutoffs[2])
    NA24385_30x = generate_table_line(NA24385_30x_table_files, gq_cutoffs[3])
    NA24385_40x = generate_table_line(NA24385_40x_table_files, gq_cutoffs[4])
    NA24385_50x = generate_table_line(NA24385_50x_table_files, gq_cutoffs[5])
    NA24385_69x = generate_table_line(NA24385_69x_table_files, gq_cutoffs[6])

    NA24149_32x = generate_table_line(NA24149_32x_table_files, gq_cutoffs[7])
    NA24143_30x = generate_table_line(NA24143_30x_table_files, gq_cutoffs[8])

    s = '''
\\begin{{table}}[htbp]
\\centering
\\begin{{tabular}}{{lllllll}}
\\hline
Genome      & Read & SNVs    & Precision     & Recall    & Outside GIAB  & Run time  \\\\
            & Coverage & called    &    &  & high-confidence       & (hours)          \\\\
\\hline
NA12878   & $30\\times$ & {} & ${:.3f}$ & ${:.3f}$ & ${}$ & {} \\\\
NA12878   & $44\\times$ & {} & ${:.3f}$ & ${:.3f}$ & ${}$ & {} \\\\
NA24385 (AJ son) & $20\\times$ & ${}$ & ${:.3f}$ & ${:.3f}$ & ${}$ & {} \\\\
NA24385 (AJ son) & $30\\times$ & ${}$ & ${:.3f}$ & ${:.3f}$ & ${}$ & {} \\\\
NA24385 (AJ son) & $40\\times$ & ${}$ & ${:.3f}$ & ${:.3f}$ & ${}$ & {} \\\\
NA24385 (AJ son) & $50\\times$ & ${}$ & ${:.3f}$ & ${:.3f}$ & ${}$ & {} \\\\
NA24385 (AJ son) & $69\\times$ & ${}$ & ${:.3f}$ & ${:.3f}$ & ${}$ & {} \\\\
NA24149 (AJ father) & $32\\times$ & ${}$ & ${:.3f}$ & ${:.3f}$ & ${}$ & {} \\\\
NA24143 (AJ mother) & $30\\times$ & ${}$ & ${:.3f}$ & ${:.3f}$ & ${}$ & {} \\\\
\\hline
\\end{{tabular}}
\\caption{{{{\\bf Summary of variants called on GIAB genomes.}}}}
\\label{{tab:stats}}
\\end{{table}}
'''.format(NA12878_30x.SNVs_called, NA12878_30x.precision, NA12878_30x.recall, NA12878_30x.outside_GIAB, NA12878_30x.runtime,
           NA12878_44x.SNVs_called, NA12878_44x.precision, NA12878_44x.recall, NA12878_44x.outside_GIAB, NA12878_44x.runtime,
           NA24385_20x.SNVs_called, NA24385_20x.precision, NA24385_20x.recall, NA24385_20x.outside_GIAB, NA24385_20x.runtime,
           NA24385_30x.SNVs_called, NA24385_30x.precision, NA24385_30x.recall, NA24385_30x.outside_GIAB, NA24385_30x.runtime,
           NA24385_40x.SNVs_called, NA24385_40x.precision, NA24385_40x.recall, NA24385_40x.outside_GIAB, NA24385_40x.runtime,
           NA24385_50x.SNVs_called, NA24385_50x.precision, NA24385_50x.recall, NA24385_50x.outside_GIAB, NA24385_50x.runtime,
           NA24385_69x.SNVs_called, NA24385_69x.precision, NA24385_69x.recall, NA24385_69x.outside_GIAB, NA24385_69x.runtime,
           NA24149_32x.SNVs_called, NA24149_32x.precision, NA24149_32x.recall, NA24149_32x.outside_GIAB, NA24149_32x.runtime,
           NA24143_30x.SNVs_called, NA24143_30x.precision, NA24143_30x.recall, NA24143_30x.outside_GIAB, NA24143_30x.runtime)

    with open(outfile,'w') as outf:
        print(s, file=outf)

MAX_DEPTH = 50
def plot_depth_of_mapped_vs_breadth(inputs, labels, colors, output_file):

    plt.figure(figsize=(6,6))
    ax = plt.subplot(111)

    def get_depth_breadth(histogram_file):
        breadth = defaultdict(int)
        chr_sizes = dict()
        with open(histogram_file,'r') as infile:
            for line in infile:
                el = line.strip().split('\t')

                chrom = el[0]
                depth = int(el[1])
                num_bases = int(el[2])
                chr_size = int(el[3])
                if chrom in chr_sizes:
                    assert(chr_sizes[chrom] == chr_size)
                else:
                    chr_sizes[chrom] = chr_size

                if depth > MAX_DEPTH:
                    depth = MAX_DEPTH
                breadth[depth] += num_bases

        # cumulative breadth
        cml_breadth = defaultdict(int)

        # sorted (depth, breadth) pairs
        s_breadth = sorted(list(breadth.items()))

        for d, b in s_breadth:
            for d2,b2 in s_breadth:
                if d2 >= d:
                    cml_breadth[d] += b2

        d_val = []
        b_frac = []
        genome_len = sum(chr_sizes.values())*1.0
        # sorted cumulative breadth
        for d in range(0,51):
            d_val.append(d)
            b_frac.append(cml_breadth[d]/genome_len)
        #for d, b in sorted(list(cml_breadth.items())):
        #    d_val.append(d)
        #    b_frac.append(b/genome_len)

        return d_val, b_frac

    for input,label,color in zip(inputs, labels, colors):
        #if 'mapq0' not in input and 'mapq30' not in input:
        #    continue
        d_val, b_frac = get_depth_breadth(input)
        print(label + ':')
        print("depth\tbreadth")
        for d,b in zip(d_val, b_frac):
            print("{}\t{}".format(d, b))
        print("")
        plt.plot(d_val,b_frac,color=color,label=label)

    plt.grid(True,color='grey',linestyle='--',alpha=0.5)

    ax.spines["top"].set_visible(False)
    ax.spines["right"].set_visible(False)
    ax.spines["bottom"].set_visible(False)
    ax.spines["left"].set_visible(False)
    plt.tick_params(axis="both", which="both", bottom="off", top="off",
                labelbottom="on", left="off", right="off", labelleft="on")

    plt.xlabel('Recall')
    plt.ylabel('Precision')

    plt.legend(loc='lower left')
    plt.xlabel('Minimum Depth of Mapped Reads')
    plt.ylabel('Fraction of Genome Covered')
    plt.tight_layout()

    plt.savefig(output_file)

def make_variant_counts_table(chr1_22_region_size_file,
                              segmental_duplications_95_region_size_file,
                              segmental_duplications_99_region_size_file,
                              confident_region_size_file,
                              nonconfident_region_size_file,
                              illumina_genome_stats,
                              illumina_segdup95_stats,
                              illumina_segdup99_stats,
                              illumina_GIAB_confident_stats,
                              illumina_GIAB_nonconfident_stats,
                              pacbio_genome_stats,
                              pacbio_segdup95_stats,
                              pacbio_segdup99_stats,
                              pacbio_GIAB_confident_stats,
                              pacbio_GIAB_nonconfident_stats,
                              pacbio_minus_illumina_genome_stats,
                              pacbio_minus_illumina_segdup95_stats,
                              pacbio_minus_illumina_segdup99_stats,
                              pacbio_minus_illumina_GIAB_confident_stats,
                              pacbio_minus_illumina_GIAB_nonconfident_stats,
                              illumina_minus_pacbio_genome_stats,
                              illumina_minus_pacbio_segdup95_stats,
                              illumina_minus_pacbio_segdup99_stats,
                              illumina_minus_pacbio_GIAB_confident_stats,
                              illumina_minus_pacbio_GIAB_nonconfident_stats,
                              intersect_illumina_pacbio_genome_stats,
                              intersect_illumina_pacbio_segdup95_stats,
                              intersect_illumina_pacbio_segdup99_stats,
                              intersect_illumina_pacbio_GIAB_confident_stats,
                              intersect_illumina_pacbio_GIAB_nonconfident_stats,
                              outfile):


    def read_region_size(region_size_file):
        with open(region_size_file,'r') as inf:
            return int(inf.readline().strip())

    # read in files containing bed file total lengths
    chr1_22_region_size = read_region_size(chr1_22_region_size_file)
    segmental_duplications_95_region_size = read_region_size(segmental_duplications_95_region_size_file)
    segmental_duplications_99_region_size = read_region_size(segmental_duplications_99_region_size_file)
    confident_region_size = read_region_size(confident_region_size_file)
    nonconfident_region_size = read_region_size(nonconfident_region_size_file)

    # TsTv and num SNVs for illumina short reads
    illumina_genome_TsTv = get_TsTv(illumina_genome_stats)
    illumina_genome_numSNVs = get_snp_count(illumina_genome_stats)

    illumina_segdup95_TsTv = get_TsTv(illumina_segdup95_stats)
    illumina_segdup95_numSNVs = get_snp_count(illumina_segdup95_stats)

    illumina_segdup99_TsTv = get_TsTv(illumina_segdup99_stats)
    illumina_segdup99_numSNVs = get_snp_count(illumina_segdup99_stats)

    illumina_GIAB_confident_TsTv = get_TsTv(illumina_GIAB_confident_stats)
    illumina_GIAB_confident_numSNVs = get_snp_count(illumina_GIAB_confident_stats)

    illumina_GIAB_nonconfident_TsTv = get_TsTv(illumina_GIAB_nonconfident_stats)
    illumina_GIAB_nonconfident_numSNVs = get_snp_count(illumina_GIAB_nonconfident_stats)


    # TsTv and num SNVs for pacbio long reads
    pacbio_genome_TsTv = get_TsTv(pacbio_genome_stats)
    pacbio_genome_numSNVs = get_snp_count(pacbio_genome_stats)

    pacbio_segdup95_TsTv = get_TsTv(pacbio_segdup95_stats)
    pacbio_segdup95_numSNVs = get_snp_count(pacbio_segdup95_stats)

    pacbio_segdup99_TsTv = get_TsTv(pacbio_segdup99_stats)
    pacbio_segdup99_numSNVs = get_snp_count(pacbio_segdup99_stats)

    pacbio_GIAB_confident_TsTv = get_TsTv(pacbio_GIAB_confident_stats)
    pacbio_GIAB_confident_numSNVs = get_snp_count(pacbio_GIAB_confident_stats)

    pacbio_GIAB_nonconfident_TsTv = get_TsTv(pacbio_GIAB_nonconfident_stats)
    pacbio_GIAB_nonconfident_numSNVs = get_snp_count(pacbio_GIAB_nonconfident_stats)

    # TsTv and num SNVs for SNVs unique to pacbio
    pacbio_minus_illumina_genome_TsTv = get_TsTv(pacbio_minus_illumina_genome_stats)
    pacbio_minus_illumina_genome_numSNVs = get_snp_count(pacbio_minus_illumina_genome_stats)

    pacbio_minus_illumina_segdup95_TsTv = get_TsTv(pacbio_minus_illumina_segdup95_stats)
    pacbio_minus_illumina_segdup95_numSNVs = get_snp_count(pacbio_minus_illumina_segdup95_stats)

    pacbio_minus_illumina_segdup99_TsTv = get_TsTv(pacbio_minus_illumina_segdup99_stats)
    pacbio_minus_illumina_segdup99_numSNVs = get_snp_count(pacbio_minus_illumina_segdup99_stats)

    pacbio_minus_illumina_GIAB_confident_TsTv = get_TsTv(pacbio_minus_illumina_GIAB_confident_stats)
    pacbio_minus_illumina_GIAB_confident_numSNVs = get_snp_count(pacbio_minus_illumina_GIAB_confident_stats)

    pacbio_minus_illumina_GIAB_nonconfident_TsTv = get_TsTv(pacbio_minus_illumina_GIAB_nonconfident_stats)
    pacbio_minus_illumina_GIAB_nonconfident_numSNVs = get_snp_count(pacbio_minus_illumina_GIAB_nonconfident_stats)

    # TsTv and num SNVs for SNVs unique to illumina
    illumina_minus_pacbio_genome_TsTv = get_TsTv(illumina_minus_pacbio_genome_stats)
    illumina_minus_pacbio_genome_numSNVs = get_snp_count(illumina_minus_pacbio_genome_stats)

    illumina_minus_pacbio_segdup95_TsTv = get_TsTv(illumina_minus_pacbio_segdup95_stats)
    illumina_minus_pacbio_segdup95_numSNVs = get_snp_count(illumina_minus_pacbio_segdup95_stats)

    illumina_minus_pacbio_segdup99_TsTv = get_TsTv(illumina_minus_pacbio_segdup99_stats)
    illumina_minus_pacbio_segdup99_numSNVs = get_snp_count(illumina_minus_pacbio_segdup99_stats)

    illumina_minus_pacbio_GIAB_confident_TsTv = get_TsTv(illumina_minus_pacbio_GIAB_confident_stats)
    illumina_minus_pacbio_GIAB_confident_numSNVs = get_snp_count(illumina_minus_pacbio_GIAB_confident_stats)

    illumina_minus_pacbio_GIAB_nonconfident_TsTv = get_TsTv(illumina_minus_pacbio_GIAB_nonconfident_stats)
    illumina_minus_pacbio_GIAB_nonconfident_numSNVs = get_snp_count(illumina_minus_pacbio_GIAB_nonconfident_stats)

    # TsTv and num SNVs for intersection of illumina and pacbio long reads
    intersect_illumina_pacbio_genome_TsTv = get_TsTv(intersect_illumina_pacbio_genome_stats)
    intersect_illumina_pacbio_genome_numSNVs = get_snp_count(intersect_illumina_pacbio_genome_stats)

    intersect_illumina_pacbio_segdup95_TsTv = get_TsTv(intersect_illumina_pacbio_segdup95_stats)
    intersect_illumina_pacbio_segdup95_numSNVs = get_snp_count(intersect_illumina_pacbio_segdup95_stats)

    intersect_illumina_pacbio_segdup99_TsTv = get_TsTv(intersect_illumina_pacbio_segdup99_stats)
    intersect_illumina_pacbio_segdup99_numSNVs = get_snp_count(intersect_illumina_pacbio_segdup99_stats)

    intersect_illumina_pacbio_GIAB_confident_TsTv = get_TsTv(intersect_illumina_pacbio_GIAB_confident_stats)
    intersect_illumina_pacbio_GIAB_confident_numSNVs = get_snp_count(intersect_illumina_pacbio_GIAB_confident_stats)

    intersect_illumina_pacbio_GIAB_nonconfident_TsTv = get_TsTv(intersect_illumina_pacbio_GIAB_nonconfident_stats)
    intersect_illumina_pacbio_GIAB_nonconfident_numSNVs = get_snp_count(intersect_illumina_pacbio_GIAB_nonconfident_stats)

    s = '''
\\begin{{table}}[htbp]
\\centering
\\small
\\begin{{tabular}}{{lllllll}}
\\hline
                                                                        &                        & Genome  & Inside GIAB & Outside GIAB & Segmental Dup.       & Segmental Dup.       \\\\
                                                                        &                        & (1-22)  & Confident   & Confident    & ($\geq 95\%$ similar)& ($\geq 99\%$ similar)\\\\
\\hline
Region size                                                             &                        & {}      & {}          & {}           & {}                   & {}                   \\tabularnewline
\\cellcolor[gray]{{0.9}}                                                &\\cellcolor[gray]{{0.9}}\# SNVs                &\\cellcolor[gray]{{0.9}}{:,}    &\\cellcolor[gray]{{0.9}}{:,}        &\\cellcolor[gray]{{0.9}}{:,}         &\\cellcolor[gray]{{0.9}}{:,}                 &\\cellcolor[gray]{{0.9}}{:,}                 \\tabularnewline
\\multirow{{-2}}{{*}}{{\\cellcolor[gray]{{0.9}}PacBio}}               &\\cellcolor[gray]{{0.9}}Ts/Tv &\\cellcolor[gray]{{0.9}}{}      &\\cellcolor[gray]{{0.9}}{}          &\\cellcolor[gray]{{0.9}}{}           &\\cellcolor[gray]{{0.9}}{}                   &\\cellcolor[gray]{{0.9}}{}                   \\tabularnewline
                                                                        & \# SNVs                & {:,}    & {:,}        & {:,}         & {:,}                 & {:,}                 \\tabularnewline
\\multirow{{-2}}{{*}}{{Illumina}}                                         & Ts/Tv                  & {}      & {}          & {}           & {}                   & {}                   \\tabularnewline
\\cellcolor[gray]{{0.9}}                                                      &\\cellcolor[gray]{{0.9}}\# SNVs                &\\cellcolor[gray]{{0.9}}{:,}    &\\cellcolor[gray]{{0.9}}{:,}        &\\cellcolor[gray]{{0.9}}{:,}         &\\cellcolor[gray]{{0.9}}{:,}                 &\\cellcolor[gray]{{0.9}}{:,}                 \\tabularnewline
\\multirow{{-2}}{{*}}{{\\cellcolor[gray]{{0.9}}Unique to PacBio}}       &\\cellcolor[gray]{{0.9}}Ts/Tv &\\cellcolor[gray]{{0.9}}{}      &\\cellcolor[gray]{{0.9}}{}          &\\cellcolor[gray]{{0.9}}{}           &\\cellcolor[gray]{{0.9}}{}                   &\\cellcolor[gray]{{0.9}}{}                   \\tabularnewline
                                                      &  \# SNVs                &  {:,}    &  {:,}        &  {:,}         &  {:,}                 &  {:,}                 \\tabularnewline
\\multirow{{-2}}{{*}}{{Unique to Illumina}}       & Ts/Tv & {}      &  {}          &  {}           &  {}                   &  {}                   \\tabularnewline
\\cellcolor[gray]{{0.9}}Shared                                         &\\cellcolor[gray]{{0.9}}\# SNVs                &\\cellcolor[gray]{{0.9}}{:,}    &\\cellcolor[gray]{{0.9}}{:,}        &\\cellcolor[gray]{{0.9}}{:,}         &\\cellcolor[gray]{{0.9}}{:,}                 &\\cellcolor[gray]{{0.9}}{:,}                 \\tabularnewline
\\cellcolor[gray]{{0.9}}Illumina \\& PacBio                             &\\cellcolor[gray]{{0.9}}Ts/Tv                  &\\cellcolor[gray]{{0.9}}{}      &\\cellcolor[gray]{{0.9}}{}          &\\cellcolor[gray]{{0.9}}{}           &\\cellcolor[gray]{{0.9}}{}                   &\\cellcolor[gray]{{0.9}}{}                   \\tabularnewline
\\hline
\\end{{tabular}}
\\caption{{{{\\bf Number of variants called for NA12878 in various genomic regions with short reads ($\mathbf{{30\\times}}$ coverage) and long reads ($\mathbf{{44\\times}}$ coverage).
Statistics are also shown for the variants unique to each technology and the variants shared by both.}}}}
\\label{{tab:variant_counts}}
\\end{{table}}
'''.format(format_bp(chr1_22_region_size), format_bp(confident_region_size), format_bp(nonconfident_region_size), format_bp(segmental_duplications_95_region_size), format_bp(segmental_duplications_99_region_size),
           pacbio_genome_numSNVs, pacbio_GIAB_confident_numSNVs, pacbio_GIAB_nonconfident_numSNVs, pacbio_segdup95_numSNVs, pacbio_segdup99_numSNVs,
           pacbio_genome_TsTv, pacbio_GIAB_confident_TsTv, pacbio_GIAB_nonconfident_TsTv, pacbio_segdup95_TsTv, pacbio_segdup99_TsTv,
           illumina_genome_numSNVs, illumina_GIAB_confident_numSNVs, illumina_GIAB_nonconfident_numSNVs, illumina_segdup95_numSNVs, illumina_segdup99_numSNVs,
           illumina_genome_TsTv, illumina_GIAB_confident_TsTv, illumina_GIAB_nonconfident_TsTv, illumina_segdup95_TsTv, illumina_segdup99_TsTv,
           pacbio_minus_illumina_genome_numSNVs, pacbio_minus_illumina_GIAB_confident_numSNVs, pacbio_minus_illumina_GIAB_nonconfident_numSNVs, pacbio_minus_illumina_segdup95_numSNVs, pacbio_minus_illumina_segdup99_numSNVs,
           pacbio_minus_illumina_genome_TsTv, pacbio_minus_illumina_GIAB_confident_TsTv, pacbio_minus_illumina_GIAB_nonconfident_TsTv, pacbio_minus_illumina_segdup95_TsTv, pacbio_minus_illumina_segdup99_TsTv,
           illumina_minus_pacbio_genome_numSNVs, illumina_minus_pacbio_GIAB_confident_numSNVs, illumina_minus_pacbio_GIAB_nonconfident_numSNVs, illumina_minus_pacbio_segdup95_numSNVs, illumina_minus_pacbio_segdup99_numSNVs,
           illumina_minus_pacbio_genome_TsTv, illumina_minus_pacbio_GIAB_confident_TsTv, illumina_minus_pacbio_GIAB_nonconfident_TsTv, illumina_minus_pacbio_segdup95_TsTv, illumina_minus_pacbio_segdup99_TsTv,
           intersect_illumina_pacbio_genome_numSNVs, intersect_illumina_pacbio_GIAB_confident_numSNVs, intersect_illumina_pacbio_GIAB_nonconfident_numSNVs, intersect_illumina_pacbio_segdup95_numSNVs, intersect_illumina_pacbio_segdup99_numSNVs,
           intersect_illumina_pacbio_genome_TsTv, intersect_illumina_pacbio_GIAB_confident_TsTv, intersect_illumina_pacbio_GIAB_nonconfident_TsTv,  intersect_illumina_pacbio_segdup95_TsTv, intersect_illumina_pacbio_segdup99_TsTv)

    with open(outfile,'w') as outf:
        print(s, file=outf)


def plot_fp_near_indel(fp_vcfs, fixed_gq_VCFstats, scaled_gq_VCFstats, ground_truth,
                       output_png, cov, fixed_gq, scaled_gqs):

    fixed_gq_fp = []
    scaled_gq_fp = []

    for fp_vcf, fixed_gq_VCFstat, scaled_gq_VCFstat, scaled_gq in zip(fp_vcfs, fixed_gq_VCFstats, scaled_gq_VCFstats, scaled_gqs):

        fixed_gq_count = count_fp_near_true_indel(fp_vcf, ground_truth, fixed_gq)
        scaled_gq_count = count_fp_near_true_indel(fp_vcf, ground_truth, scaled_gq)

        # count the total # of SNVs called at this cutoff
        fixed_gq_total = get_snp_count(fixed_gq_VCFstat)
        scaled_gq_total = get_snp_count(scaled_gq_VCFstat)

        fixed_gq_fp.append(fixed_gq_count / fixed_gq_total)
        scaled_gq_fp.append(scaled_gq_count / scaled_gq_total)

    plt.figure();
    ax1 = plt.subplot(111)

    plt.plot(cov, fixed_gq_fp, color='r',label='Fixed GQ={}'.format(fixed_gq),linewidth=3,alpha=0.75)
    plt.plot(cov, scaled_gq_fp, color='b',label='Coverage Scaled GQ',linewidth=3,alpha=0.75)

    plt.grid(True,color='grey',linestyle='--',alpha=0.5)

    ax1.spines["top"].set_visible(False)
    ax1.spines["right"].set_visible(False)
    ax1.spines["bottom"].set_visible(False)
    ax1.spines["left"].set_visible(False)
    plt.tick_params(axis="both", which="both", bottom="off", top="off",
                labelbottom="on", left="off", right="off", labelleft="on")

    #plt.xlim(xlim)
    #plt.ylim(ylim)
    plt.xlabel('Read Coverage')
    plt.ylabel('Rate of FP SNVs at true indel sites')
    plt.legend(loc='upper left')
    plt.tight_layout()
    ax1.set_axisbelow(True)
    plt.savefig(output_png)

def actual_to_effective_read_coverage_plot(vcfgz_file, output_file):

    actual = []
    effective = []
    with pysam.VariantFile(vcfgz_file) as vcf:
        for rec in vcf:

            ac = sum(rec.info['AC']) + rec.info['AM'] #rec.info['DP']
            ef = sum(rec.info['AC'])
            actual.append(ac)
            effective.append(ef)

    d = defaultdict(list)
    for a,e in zip(actual, effective):
        d[a].append(e)

    medians_x = []
    medians_y = []
    for a, lst in sorted(list(d.items())):
        medians_x.append(a)
        medians_y.append(statistics.median(lst))

    plt.figure()
    #import pdb; pdb.set_trace()
    #data = pd.DataFrame(
    #{'Actual read coverage': actual,
    # 'Effective read coverage': effective,
    #})
    #ax = sns.jointplot(data=data,x='Actual read coverage',y='Effective read coverage', color='k', kind='hex')
    ax1 = plt.subplot(111)

    plt.grid(True,color='grey',linestyle='--',alpha=0.5)

    #plt.scatter(actual, effective, color='b',marker='.',s=1,alpha=0.75,label='Single variant site')

    plt.plot([min(medians_x),max(medians_x)], [min(medians_x),max(medians_x)], color='k',linestyle=':',alpha=0.75,linewidth=3,label='Optimal effective coverage (diagonal)')
    plt.plot(medians_x, medians_y, color='r',alpha=0.75,linewidth=3,label='Median effective coverage')

    ax1.spines["top"].set_visible(False)
    ax1.spines["right"].set_visible(False)
    ax1.spines["bottom"].set_visible(False)
    ax1.spines["left"].set_visible(False)
    plt.tick_params(axis="both", which="both", bottom="off", top="off",
                labelbottom="on", left="off", right="off", labelleft="on")

    plt.legend(loc='upper left')
    plt.xlabel('Actual Read Coverage')
    plt.ylabel('Effective Read Coverage')
    plt.tight_layout()
    plt.savefig(output_file)


def plot_mappability_bars(pacbio_mf_0_0,
                          pacbio_mf_0_5,
                          pacbio_mf_0_75,
                          pacbio_mf_0_9,
                          pacbio_mf_1_0,
                          illumina_mf_0_0,
                          illumina_mf_0_5,
                          illumina_mf_0_75,
                          illumina_mf_0_9,
                          illumina_mf_1_0,
                          output_file,
                          total_nonN_bases):

    plt.figure(figsize=(8.5,4))
    #mpl.rcParams['axes.titlepad'] = 50
    ax = plt.subplot(111)

    width = 0.005
    alpha1 = 0.6

    #ind = np.array([0,0.04,0.08,0.12,0.16])
    ind = np.array([0,0.04,0.08])

    def parse_datafile_lst(datafile_lst):
        lst = []

        for datafile in datafile_lst:
            with open(datafile,'r') as inf:
                num_positions = float(inf.readline().strip())
                lst.append(num_positions / total_nonN_bases)

        return lst

    pacbio_mf_0_0_data = parse_datafile_lst(pacbio_mf_0_0)[2:]
    pacbio_mf_0_5_data = parse_datafile_lst(pacbio_mf_0_5)[2:]
    pacbio_mf_0_75_data = parse_datafile_lst(pacbio_mf_0_75)[2:]
    pacbio_mf_0_9_data = parse_datafile_lst(pacbio_mf_0_9)[2:]
    pacbio_mf_1_0_data = parse_datafile_lst(pacbio_mf_1_0)[2:]
    illumina_mf_0_0_data = parse_datafile_lst(illumina_mf_0_0)[2:]
    illumina_mf_0_5_data = parse_datafile_lst(illumina_mf_0_5)[2:]
    illumina_mf_0_75_data = parse_datafile_lst(illumina_mf_0_75)[2:]
    illumina_mf_0_9_data = parse_datafile_lst(illumina_mf_0_9)[2:]
    illumina_mf_1_0_data = parse_datafile_lst(illumina_mf_1_0)[2:]

    def plot_bars(vals,color,ix,lab):
        plt.bar(ind+ix*width, vals, color=color,
                ecolor='black', # black error bar color
                alpha=alpha1,      # transparency
                width=width,      # smaller bar width
                align='center',
                label=lab,
                zorder=0)

    #plot_bars(pacbio_mf_0_0_data,'#c3d6f4',0,'PacBio, all sites')
    plot_bars(pacbio_mf_0_5_data,'#93bcff',1,'PacBio, at least 50% well-mapped')
    plot_bars(pacbio_mf_0_75_data,'#609dff',2,'PacBio, at least 75% well-mapped')
    plot_bars(pacbio_mf_0_9_data,'#3582ff',3,'PacBio, at least 90% well-mapped')
    #plot_bars(pacbio_mf_1_0_data,'#0061ff',4,'PacBio, 100% well-mapped')

    #plot_bars(illumina_mf_0_0_data,'#ffa0a0',5,'Illumina, all sites')
    plot_bars(illumina_mf_0_5_data,'#ff7272',4,'Illumina, at least 50% well-mapped')
    plot_bars(illumina_mf_0_75_data,'#ff4242',5,'Illumina, at least 75% well-mapped')
    plot_bars(illumina_mf_0_9_data,'#ff2323',6,'Illumina, at least 90% well-mapped')
    #plot_bars(illumina_mf_1_0_data,'#ff0000',9,'Illumina, 100% well-mapped')

    ax.yaxis.grid(True,color='grey', alpha=0.5, linestyle='--',zorder=1.0)
    ax.spines["top"].set_visible(False)
    ax.spines["right"].set_visible(False)
    ax.spines["bottom"].set_visible(False)
    ax.spines["left"].set_visible(False)
    plt.tick_params(axis="both", which="both", bottom=False, top=False,
                labelbottom=True, left=False, right=False, labelleft=True)

    ax.set_xticks(ind+3.5*width)
    ax.set_xticklabels(['30','40','50'])

    plt.xlabel('Minimum read coverage')
    plt.ylabel('Fraction of genome covered (chr. 1-22)')
    plt.ylim((0.8,1.0))
    plt.legend(loc='upper right')
    plt.tight_layout()

    ax.set_axisbelow(True)

    ticklabelpad = mpl.rcParams['xtick.major.pad']

    #ax.annotate('coverage', xy=(-0.1,-0.03), xytext=(5, -ticklabelpad), ha='left', va='top',
    #            xycoords='axes fraction', textcoords='offset points')

    plt.savefig(output_file)

def mendelian_concordance_table(pacbio_row, illumina_row, outfile):

    consistency_re = re.compile("\s+F\+M:\d+\/\d+\s+\((\d+\.\d+%)\)\n")
    def parse_mendelian_output(mendelian_output):
        with open(mendelian_output,'r') as inf:
            file_contents = inf.read()
            return consistency_re.findall(file_contents)[0]


    pacbio_data = [parse_mendelian_output(f).replace('%','\%') for f in pacbio_row]
    illumina_data = [parse_mendelian_output(f).replace('%','\%') for f in illumina_row]

    # read in files containing bed file total lengths

    s = '''
\\begin{{table}}[htbp]
\\centering
\\small
\\begin{{tabular}}{{llllll}}
\\hline
         & Genome  & Inside GIAB & Outside GIAB & Segmental Dup.       & Segmental Dup.       \\\\
         & (1-22)  & Confident   & Confident    & ($\geq 95\%$ similar)& ($\geq 99\%$ similar)\\\\
\\hline
PacBio   & {}      & {}          & {}           & {}                   & {}                   \\tabularnewline
Illumina & {}      & {}          & {}           & {}                   & {}                   \\tabularnewline
\\hline
\\end{{tabular}}
\\caption{{{{\\bf Mendelian consistency for AJ Trio between variants called using PacBio reads
($\\mathbf{{69\\times}}$ coverage son, $\\mathbf{{30\\times}}$ coverage mother, $\\mathbf{{32\\times}}$ coverage father),
and variants called using Illumina reads ($\\mathbf{{60\\times}}$ coverage son, $\\mathbf{{30\\times}}$ coverage mother, $\\mathbf{{30\\times}}$ coverage father).
Results are shown for genome-wide variants as well as variants within specific genomic regions.}}}}
\\label{{tab:mendelian}}
\\end{{table}}
'''.format(*pacbio_data,
           *illumina_data)

    with open(outfile,'w') as outf:
        print(s, file=outf)

def make_dup_gene_table(gene_names, regions, pb_SNV_stats, il_SNV_stats, shared_SNV_stats, pb_frac_map, il_frac_map, output_file):

    def parse_file(infile):
        with open(infile,'r') as inf:
            return inf.read().strip()

    with open(output_file,'w') as outf:

        head_part = '''\\begin{table}[htbp]
\\centering
\\small
\\begin{tabular}{lllllll}
\\hline
Gene & Region & \# SNVs & \# SNVs   & \# SNVs & \% Mappable  & \% Mappable \\\\
Name &        & PacBio  & Illumina  & Shared  & PacBio       &  Illumina   \\\\
\\hline'''

        print(head_part,file=outf)

        for gene_name, region_file, pb_stats_file, il_stats_file, shared_stats_file, pb_frac_map_file, il_frac_map_file in zip(gene_names, regions, pb_SNV_stats, il_SNV_stats, shared_SNV_stats, pb_frac_map, il_frac_map):

            region = parse_file(region_file)

            pb_num_SNVs = get_snp_count(pb_stats_file)
            il_num_SNVs = get_snp_count(il_stats_file)
            shared_num_SNVs = get_snp_count(shared_stats_file)

            pb_frac_map = float(parse_file(pb_frac_map_file))
            il_frac_map = float(parse_file(il_frac_map_file))

            line = '{} & {} & {} & {} & {} & {:.1f}\% & {:.1f}\% \\\\'.format(gene_name, region,
                                                  pb_num_SNVs, il_num_SNVs, shared_num_SNVs,
                                                  pb_frac_map*100, il_frac_map*100)
            print(line,file=outf)

        tail_part = '''\\hline
\\end{tabular}
\\caption{{\\bf Summary of read mappability and variants called for genes occuring
inside segmental duplications.} Data shown is for NA12878, $30\\times$ coverage
Illumina reads and $44\\times$ coverage PacBio reads. For the purposes of this
figure ``Mappable" is defined as having at least $10\\times$ coverage of
well-mapped reads (mapq $\\geq 30$).}
\\label{tab:mendelian}
\\end{table}'''

        print(tail_part,file=outf)


if __name__ == '__main__':
    args = parseargs()
    plot_vcfeval(args.input_dirs, args.labels, args.output_file, args.title)
