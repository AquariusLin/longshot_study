import matplotlib as mpl
mpl.use('Agg')
from matplotlib import pyplot as plt
import pickle
import os
import gzip
import argparse
import numpy as np
import re
from collections import namedtuple
from collections import defaultdict
import sys
sys.path.append('HapCUT2/utilities')
import calculate_haplotype_statistics


mpl.rc('legend', fontsize=9)
mpl.rc('xtick', labelsize=9)
mpl.rc('ytick', labelsize=9)
mpl.rc('axes', labelsize=9)
mpl.rc('axes', labelsize=9)
mpl.rcParams.update({'font.size': 9})
mpl.rc('lines', linewidth=1.5)
mpl.rc('mathtext',default='regular')

def parseargs():

    parser = argparse.ArgumentParser(description='this tool is meant to make precision-recall curves from RTGtools vcfeval data, that are prettier than those from RTGtools rocplot function.')
    parser.add_argument('-i', '--input_dirs', nargs='+', type = str, help='list of directories generated by RTGtools vcfeval tool', default=None)
    parser.add_argument('-l', '--labels', nargs='+', type = str, help='list of labels to associate to input_dirs', default=None)
    parser.add_argument('-o', '--output_file', nargs='?', type = str, help='PNG file to write plot to.', default=None)
    parser.add_argument('-t', '--title', nargs='?', type = str, help='title for plot', default=None)

    args = parser.parse_args()
    return args

def plot_vcfeval(dirlist, labels, output_file, title, colors=['r','#3333ff','#ccccff','#9999ff','#8080ff','#6666ff'], xlim=(0.6,1.0), ylim=(0.95,1.0), legendloc='lower left'):


    # add a small amount of padding to the xlim and ylim so that grid lines show up on the borders
    xpad = (xlim[1] - xlim[0])/100
    ypad = (ylim[1] - ylim[0])/100
    xlim = (xlim[0]-xpad, xlim[1]+xpad)
    ylim = (ylim[0]-ypad, ylim[1]+ypad)

    plt.figure();
    ax1 = plt.subplot(111);
    if title != None:
        plt.title(title)

    if len(dirlist) > len(colors):
        print("need to define larger color pallet to plot this many datasets.")
        exit(1)

    for color, path, label in zip(colors, dirlist,labels):

        #quals = []
        recalls = []
        precisions = []

        with gzip.open(os.path.join(path,'snp_roc.tsv.gz'),mode='rt') as inf:

            for line in inf:
                if line[0] == '#':
                    continue
                else:
                    el = [float(x) for x in line.strip().split()]
                    assert(len(el) == 8)
                    #quals.append(el[0])
                    precisions.append(el[5])
                    recalls.append(el[6])

        plt.plot(recalls, precisions, color=color,label=label,linewidth=3,alpha=0.75)

    plt.grid(True,color='grey',linestyle='--',alpha=0.5)

    ax1.spines["top"].set_visible(False)
    ax1.spines["right"].set_visible(False)
    ax1.spines["bottom"].set_visible(False)
    ax1.spines["left"].set_visible(False)
    plt.tick_params(axis="both", which="both", bottom="off", top="off",
                labelbottom="on", left="off", right="off", labelleft="on")

    plt.xlim(xlim)
    plt.ylim(ylim)
    plt.xlabel('Recall')
    plt.ylabel('Precision')
    plt.legend(loc=legendloc)
    plt.tight_layout()
    ax1.set_axisbelow(True)
    plt.savefig(output_file)


# input:
# vcfeval_dir: directory containing vcfeval output
# gq_cutoff: a Genotype Quality value to set as the cutoff for variants e.g. 30 or 50
# output:
# (precision, recall) : the precision and recall values for variants above the GQ cutoff
def get_precision_recall(vcfeval_dir, gq_cutoff):

    recall = None
    precision = None
    qual = None

    with gzip.open(os.path.join(vcfeval_dir,'snp_roc.tsv.gz'),mode='rt') as inf:

        for line in inf:
            if line[0] == '#':
                continue
            else:
                el = [float(x) for x in line.strip().split()]
                assert(len(el) == 8)
                new_qual = el[0]
                if new_qual < gq_cutoff:
                    break

                qual = new_qual
                precision = el[5]
                recall = el[6]

    # this should be true for large enough datasets, like we will look at,
    # and it's a nice sanity check
    assert(qual - gq_cutoff >= 0)
    assert(qual - gq_cutoff < 1.0)
    assert(precision != None)
    assert(recall != None)

    return (precision, recall)

def plot_precision_recall_bars_simulation(pacbio_dirlist_genome, illumina_dirlist_genome, pacbio_dirlist_segdup, illumina_dirlist_segdup, gq_cutoff, labels, output_file):

    plt.figure(figsize=(7,5))
    #mpl.rcParams['axes.titlepad'] = 50

    width = 0.15
    alpha1 = 0.6


    def make_subplot(ax, ind, pacbio_vals, illumina_vals, lab_pacbio=None, lab_illumina=None, fc='#ffffff'):

        plt.bar(ind+width, pacbio_vals, color='#2200ff',
                ecolor='black', # black error bar color
                alpha=alpha1,      # transparency
                width=width,      # smaller bar width
                align='center',
                label=lab_pacbio,
                zorder=0)
        plt.bar(ind+2*width, illumina_vals, color='#ff1900',
                ecolor='black', # black error bar color
                alpha=alpha1,      # transparency
                width=width,      # smaller bar width
                align='center',
                label=lab_illumina,
                zorder=0)
        # add some text for labels, title and axes ticks
        #plt.xlim(-0.5,6)


    def prettify_plot():

        ax.yaxis.grid(True,color='grey', alpha=0.5, linestyle='--',zorder=1.0)
        ax.spines["top"].set_visible(False)
        ax.spines["right"].set_visible(False)
        ax.spines["bottom"].set_visible(False)
        ax.spines["left"].set_visible(False)
        plt.tick_params(axis="both", which="both", bottom=False, top=False,
                    labelbottom=True, left=False, right=False, labelleft=True)


    ind1 = [0,0.5,1,1.5]
    ind2 = [2.25,2.75,3.25,3.75]
    ind = ind1 + ind2

    pacbio_precisions_genome, pacbio_recalls_genome = zip(*[get_precision_recall(d, gq_cutoff) for d in pacbio_dirlist_genome])
    illumina_precisions_genome, illumina_recalls_genome = zip(*[get_precision_recall(d, gq_cutoff) for d in illumina_dirlist_genome])
    pacbio_precisions_segdup, pacbio_recalls_segdup = zip(*[get_precision_recall(d, gq_cutoff) for d in pacbio_dirlist_segdup])
    illumina_precisions_segdup, illumina_recalls_segdup = zip(*[get_precision_recall(d, gq_cutoff) for d in illumina_dirlist_segdup])

    ax = plt.subplot(211)
    make_subplot(ax,np.array(ind1), pacbio_precisions_genome, illumina_precisions_genome, lab_pacbio='PacBio + Reaper', lab_illumina='Illumina + Freebayes',fc='#e0e1e2')
    make_subplot(ax, np.array(ind2), pacbio_precisions_segdup, illumina_precisions_segdup,fc='#dddddd')
    ax.legend(loc='center left', bbox_to_anchor=(0.25,1.13),ncol=2)

    plt.ylabel("Precision")
    plt.ylim(0.99,1.0)
    prettify_plot()
    ax.set_xticks([])
    ax.set_xticklabels([])

    ax = plt.subplot(212)
    plt.ylabel("Recall\n")
    make_subplot(ax, np.array(ind1), pacbio_recalls_genome, illumina_recalls_genome,fc='#e0e1e2')
    make_subplot(ax, np.array(ind2), pacbio_recalls_segdup, illumina_recalls_segdup,fc='#dddddd')
    prettify_plot()
    ax.set_xticks(np.array(ind)+1.5*width)
    ax.set_xticklabels(labels+labels)

    #ax.set_yscale('log')NA12878_prec_recall_{chrom}
    #plt.xlim(())
    #plt.ylim((0,1.0))
    #plt.legend(loc='upper left')
    plt.xlabel(" ",labelpad=10)

    plt.tight_layout()
    plt.subplots_adjust(top=0.90)
    #t = plt.suptitle(title)

    ax.set_axisbelow(True)

    ticklabelpad = mpl.rcParams['xtick.major.pad']

    ax.annotate('coverage', xy=(-0.1,-0.03), xytext=(5, -ticklabelpad), ha='left', va='top',
                xycoords='axes fraction', textcoords='offset points')
    ax.annotate('Whole Genome', xy=(0.16,-0.15), xytext=(5, -ticklabelpad), ha='left', va='top',
                xycoords='axes fraction', textcoords='offset points')
    ax.annotate('Segmental Duplications Only', xy=(0.58,-0.15), xytext=(5, -ticklabelpad), ha='left', va='top',
                xycoords='axes fraction', textcoords='offset points')

    # credit to https://stackoverflow.com/questions/4700614/how-to-put-the-legend-out-of-the-plot
    # Shrink current axis by 20%
    box = ax.get_position()
    #ax.set_position([box.x0, box.y0, box.width * 0.85, box.height])
    # Put a legend to the right of the current axis
    #ax.legend(loc='center left', bbox_to_anchor=(1, 0.5))

    #plt.show()
    plt.savefig(output_file)

def plot_precision_recall_bars_simulation_extended(pacbio_ngmlr_dirlist_genome,
                                                      pacbio_minimap2_dirlist_genome,
                                                      pacbio_bwamem_dirlist_genome,
                                                      pacbio_blasr_dirlist_genome,
                                                      illumina_dirlist_genome,
                                                      pacbio_ngmlr_dirlist_segdup,
                                                      pacbio_minimap2_dirlist_segdup,
                                                      pacbio_bwamem_dirlist_segdup,
                                                      pacbio_blasr_dirlist_segdup,
                                                      illumina_dirlist_segdup,
                                                      gq_cutoff, labels, output_file):

    plt.figure(figsize=(7,5))
    #mpl.rcParams['axes.titlepad'] = 50

    width = 0.075
    alpha1 = 0.6

    def make_subplot(ax,
                     ind,
                     pacbio_ngmlr_vals,
                     pacbio_minimap2_vals,
                     pacbio_bwamem_vals,
                     pacbio_blasr_vals,
                     illumina_vals,
                     lab_pacbio_ngmlr=None,
                     lab_pacbio_minimap2=None,
                     lab_pacbio_bwamem=None,
                     lab_pacbio_blasr=None,
                     lab_illumina=None):

        plt.bar(ind+width, pacbio_ngmlr_vals, color='#ffe500',
                ecolor='black',
                alpha=alpha1,      # transparency
                width=width,      # smaller bar width
                align='center',
                label=lab_pacbio_ngmlr,
                zorder=0)
        plt.bar(ind+2*width, pacbio_minimap2_vals, color='#00ff33',
                ecolor='black',
                alpha=alpha1,      # transparency
                width=width,      # smaller bar width
                align='center',
                label=lab_pacbio_minimap2,
                zorder=0)
        plt.bar(ind+3*width, pacbio_bwamem_vals, color='#ff0094',
                ecolor='black',
                alpha=alpha1,      # transparency
                width=width,      # smaller bar width
                align='center',
                label=lab_pacbio_bwamem,
                zorder=0)
        plt.bar(ind+4*width, pacbio_blasr_vals, color='#2200ff',
                ecolor='black',
                alpha=alpha1,      # transparency
                width=width,      # smaller bar width
                align='center',
                label=lab_pacbio_blasr,
                zorder=0)
        plt.bar(ind+5*width, illumina_vals, color='#ff1900',
                ecolor='black',
                alpha=alpha1,      # transparency
                width=width,      # smaller bar width
                align='center',
                label=lab_illumina,
                zorder=0)
        # add some text for labels, title and axes ticks
        #plt.xlim(-0.5,6)


    def prettify_plot(ax):

        ax.yaxis.grid(True,color='grey', linestyle='--', alpha=0.5, zorder=1.0)
        ax.spines["top"].set_visible(False)
        ax.spines["right"].set_visible(False)
        ax.spines["bottom"].set_visible(False)
        ax.spines["left"].set_visible(False)
        plt.tick_params(axis="both", which="both", bottom=False, top=False,
                    labelbottom=True, left=False, right=False, labelleft=True)


    ind1 = [0,0.5,1,1.5]
    ind2 = [2.25,2.75,3.25,3.75]
    ind = ind1 + ind2

    pacbio_ngmlr_precisions_genome, pacbio_ngmlr_recalls_genome = zip(*[get_precision_recall(d, gq_cutoff) for d in pacbio_ngmlr_dirlist_genome])
    pacbio_minimap2_precisions_genome, pacbio_minimap2_recalls_genome = zip(*[get_precision_recall(d, gq_cutoff) for d in pacbio_minimap2_dirlist_genome])
    pacbio_bwamem_precisions_genome, pacbio_bwamem_recalls_genome = zip(*[get_precision_recall(d, gq_cutoff) for d in pacbio_bwamem_dirlist_genome])
    pacbio_blasr_precisions_genome, pacbio_blasr_recalls_genome = zip(*[get_precision_recall(d, gq_cutoff) for d in pacbio_blasr_dirlist_genome])
    illumina_precisions_genome, illumina_recalls_genome = zip(*[get_precision_recall(d, gq_cutoff) for d in illumina_dirlist_genome])

    pacbio_ngmlr_precisions_segdup, pacbio_ngmlr_recalls_segdup = zip(*[get_precision_recall(d, gq_cutoff) for d in pacbio_ngmlr_dirlist_segdup])
    pacbio_minimap2_precisions_segdup, pacbio_minimap2_recalls_segdup = zip(*[get_precision_recall(d, gq_cutoff) for d in pacbio_minimap2_dirlist_segdup])
    pacbio_bwamem_precisions_segdup, pacbio_bwamem_recalls_segdup = zip(*[get_precision_recall(d, gq_cutoff) for d in pacbio_bwamem_dirlist_segdup])
    pacbio_blasr_precisions_segdup, pacbio_blasr_recalls_segdup = zip(*[get_precision_recall(d, gq_cutoff) for d in pacbio_blasr_dirlist_segdup])
    illumina_precisions_segdup, illumina_recalls_segdup = zip(*[get_precision_recall(d, gq_cutoff) for d in illumina_dirlist_segdup])

    ax1 = plt.subplot(211)
    make_subplot(ax=ax1,
                ind=np.array(ind1),
                pacbio_ngmlr_vals=pacbio_ngmlr_precisions_genome,
                pacbio_minimap2_vals=pacbio_minimap2_precisions_genome,
                pacbio_bwamem_vals=pacbio_bwamem_precisions_genome,
                pacbio_blasr_vals=pacbio_blasr_precisions_genome,
                illumina_vals=illumina_precisions_genome,
                lab_pacbio_ngmlr='PacBio + NGMLR + Reaper',
                lab_pacbio_minimap2='PacBio + Minimap2 + Reaper',
                lab_pacbio_bwamem='PacBio + BWA-MEM + Reaper',
                lab_pacbio_blasr='PacBio + BLASR + Reaper',
                lab_illumina='Illumina + Freebayes')

    make_subplot(ax=ax1,
                ind=np.array(ind2),
                pacbio_ngmlr_vals=pacbio_ngmlr_precisions_segdup,
                pacbio_minimap2_vals=pacbio_minimap2_precisions_segdup,
                pacbio_bwamem_vals=pacbio_bwamem_precisions_segdup,
                pacbio_blasr_vals=pacbio_blasr_precisions_segdup,
                illumina_vals=illumina_precisions_segdup)

    ax1.legend(loc='center left', bbox_to_anchor=(0.1,1.25),ncol=2)

    plt.ylabel("Precision")
    plt.ylim(0.996,1.0)
    ax1.set_xticks([])
    ax1.set_xticklabels([])

    prettify_plot(ax1)
    ax2 = plt.subplot(212)
    plt.ylabel("Recall\n")

    make_subplot(ax=ax2,
                ind=np.array(ind1),
                pacbio_ngmlr_vals=pacbio_ngmlr_recalls_genome,
                pacbio_minimap2_vals=pacbio_minimap2_recalls_genome,
                pacbio_bwamem_vals=pacbio_bwamem_recalls_genome,
                pacbio_blasr_vals=pacbio_blasr_recalls_genome,
                illumina_vals=illumina_recalls_genome)

    make_subplot(ax=ax2,
                ind=np.array(ind2),
                pacbio_ngmlr_vals=pacbio_ngmlr_recalls_segdup,
                pacbio_minimap2_vals=pacbio_minimap2_recalls_segdup,
                pacbio_bwamem_vals=pacbio_bwamem_recalls_segdup,
                pacbio_blasr_vals=pacbio_blasr_recalls_segdup,
                illumina_vals=illumina_recalls_segdup)

    ax2.set_xticks(np.array(ind)+3*width)
    ax2.set_xticklabels(labels+labels)

    #ax.set_yscale('log')NA12878_prec_recall_{chrom}
    #plt.xlim(())
    #plt.ylim((0,1.0))
    #plt.legend(loc='upper left')
    plt.xlabel(" ",labelpad=10)

    plt.tight_layout()
    plt.subplots_adjust(top=0.82)
    #t = plt.suptitle(title)

    ax2.set_axisbelow(True)

    ticklabelpad = mpl.rcParams['xtick.major.pad']

    ax2.annotate('coverage', xy=(-0.1,-0.03), xytext=(5, -ticklabelpad), ha='left', va='top',
                xycoords='axes fraction', textcoords='offset points')
    ax2.annotate('Whole Genome', xy=(0.16,-0.15), xytext=(5, -ticklabelpad), ha='left', va='top',
                xycoords='axes fraction', textcoords='offset points')
    ax2.annotate('Segmental Duplications Only', xy=(0.58,-0.15), xytext=(5, -ticklabelpad), ha='left', va='top',
                xycoords='axes fraction', textcoords='offset points')
    prettify_plot(ax2)

    # credit to https://stackoverflow.com/questions/4700614/how-to-put-the-legend-out-of-the-plot
    # Shrink current axis by 20%
    #box = ax2.get_position()
    #ax.set_position([box.x0, box.y0, box.width * 0.85, box.height])
    # Put a legend to the right of the current axis
    #ax.legend(loc='center left', bbox_to_anchor=(1, 0.5))

    #plt.show()
    plt.savefig(output_file)


def plot_haplotyping_results(reaper_errs, hapcut2_errs, output_file):
    # errs should be in order: NA12878 30x, NA12878 44x, NA24385 69x, NA24149 32x NA24143, 30x
    assert(len(reaper_errs) == 5)
    assert(len(hapcut2_errs) == 5)

    #unpickle the error objects
    reaper_errs = [pickle.load(open(f,'rb')) for f in reaper_errs]
    hapcut2_errs = [pickle.load(open(f,'rb')) for f in hapcut2_errs]

    plt.figure(figsize=(7,5))
    #mpl.rcParams['axes.titlepad'] = 50

    width = 0.15
    alpha1 = 0.6


    def make_subplot(ax, ind, reaper_vals, hapcut2_vals, lab_reaper=None, lab_hapcut2=None):

        plt.bar(ind+width, reaper_vals, color='#2200ff',
                ecolor='black', # black error bar color
                alpha=alpha1,      # transparency
                width=width,      # smaller bar width
                align='center',
                label=lab_reaper,
                zorder=0)
        plt.bar(ind+2*width, hapcut2_vals, color='k',
                ecolor='black', # black error bar color
                alpha=alpha1,      # transparency
                width=width,      # smaller bar width
                align='center',
                label=lab_hapcut2,
                zorder=0)
        # add some text for labels, title and axes ticks
        #plt.xlim(-0.5,6)


    def prettify_plot():

        ax.yaxis.grid(True,color='grey', alpha=0.5, linestyle='--',zorder=1.0)
        ax.spines["top"].set_visible(False)
        ax.spines["right"].set_visible(False)
        ax.spines["bottom"].set_visible(False)
        ax.spines["left"].set_visible(False)
        plt.tick_params(axis="both", which="both", bottom=False, top=False,
                    labelbottom=True, left=False, right=False, labelleft=True)


    ind = [0,0.5,1,1.5,2]

    ax = plt.subplot(211)
    reaper_switch_mismatch = [e.get_switch_mismatch_rate() for e in reaper_errs]
    hapcut2_switch_mismatch = [e.get_switch_mismatch_rate() for e in hapcut2_errs]
    make_subplot(ax,np.array(ind), reaper_switch_mismatch, hapcut2_switch_mismatch, lab_reaper='Reaper Haplotype', lab_hapcut2='30x Illumina + HapCUT2 Haplotype')
    ax.legend(loc='center left', bbox_to_anchor=(0.25,1.13),ncol=2)

    plt.ylabel("Switch + Mismatch Error Rate")
    #plt.ylim(0.99,1.0)
    prettify_plot()
    ax.set_xticks([])
    ax.set_xticklabels([])

    ax = plt.subplot(212)
    plt.ylabel("N50\n")
    reaper_N50 = [e.get_N50() for e in reaper_errs]
    hapcut2_N50 = [e.get_N50() for e in hapcut2_errs]
    make_subplot(ax,np.array(ind), reaper_N50, hapcut2_N50)
    prettify_plot()
    ax.set_xticks(np.array(ind)+1.5*width)
    ax.set_xticklabels(['NA12878\n30x','NA12878\n44x','NA24385\n69x','NA24149\n32x','NA24143\n30x'])

    #ax.set_yscale('log')NA12878_prec_recall_{chrom}
    #plt.xlim(())
    #plt.ylim((0,1.0))
    #plt.legend(loc='upper left')
    plt.xlabel(" ",labelpad=10)

    plt.tight_layout()
    plt.subplots_adjust(top=0.90)
    #t = plt.suptitle(title)

    ax.set_axisbelow(True)

    ticklabelpad = mpl.rcParams['xtick.major.pad']

    # credit to https://stackoverflow.com/questions/4700614/how-to-put-the-legend-out-of-the-plot
    # Shrink current axis by 20%
    box = ax.get_position()
    #ax.set_position([box.x0, box.y0, box.width * 0.85, box.height])
    # Put a legend to the right of the current axis
    #ax.legend(loc='center left', bbox_to_anchor=(1, 0.5))

    #plt.show()
    plt.savefig(output_file)


def plot_precision_recall_bars_NA12878_NA24385(pacbio_dirlist_NA24385, illumina_dirlist_NA24385,
                                               pacbio_dirlist_NA12878, illumina_dirlist_NA12878,
                                               gq_cutoffs_NA24385, gq_cutoffs_NA12878,
                                               gq_cutoff_illumina, output_file):

    plt.figure(figsize=(7,5))
    #mpl.rcParams['axes.titlepad'] = 50

    width = 0.135
    alpha1 = 0.6

    def plot_bars(ax, ind, vals, color=None, lab=None):

        plt.bar(ind+width, vals, color=color,
                ecolor='black', # black error bar color
                alpha=alpha1,      # transparency
                width=width,      # smaller bar width
                align='center',
                label=lab,
                zorder=0)

    def prettify_plot():

        ax.yaxis.grid(True,color='grey', alpha=0.5, linestyle='--',zorder=1.0)
        ax.spines["top"].set_visible(False)
        ax.spines["right"].set_visible(False)
        ax.spines["bottom"].set_visible(False)
        ax.spines["left"].set_visible(False)
        plt.tick_params(axis="both", which="both", bottom=False, top=False,
                    labelbottom=True, left=False, right=False, labelleft=True)


    ind1 = [0,0.15,0.3,0.45,0.6]
    ind2 = [0.75]
    ind3 = [1.05,1.2]
    ind4 = [1.35]

    pacbio_precisions_NA24385, pacbio_recalls_NA24385 = zip(*[get_precision_recall(d, g) for d,g in zip(pacbio_dirlist_NA24385, gq_cutoffs_NA24385)])
    illumina_precisions_NA24385, illumina_recalls_NA24385 = zip(*[get_precision_recall(d, gq_cutoff_illumina) for d in illumina_dirlist_NA24385])
    pacbio_precisions_NA12878, pacbio_recalls_NA12878 = zip(*[get_precision_recall(d, g) for d,g in zip(pacbio_dirlist_NA12878, gq_cutoffs_NA12878)])
    illumina_precisions_NA12878, illumina_recalls_NA12878 = zip(*[get_precision_recall(d, gq_cutoff_illumina) for d in illumina_dirlist_NA12878])

    ax = plt.subplot(211)
    plot_bars(ax, np.array(ind1), pacbio_precisions_NA24385,color='#2200ff',lab='PacBio SMRT')
    plot_bars(ax, np.array(ind2), illumina_precisions_NA24385,color='#ff1900',lab='Illumina')
    plot_bars(ax, np.array(ind3), pacbio_precisions_NA12878,color='#2200ff')
    plot_bars(ax, np.array(ind4), illumina_precisions_NA12878,color='#ff1900')
    ax.legend(loc='center left', bbox_to_anchor=(0.25,1.13),ncol=2)

    plt.ylabel("Precision")
    plt.ylim(0.99,1.0)
    prettify_plot()
    ax.set_xticks([])
    ax.set_xticklabels([])

    ax = plt.subplot(212)
    plt.ylabel("Recall\n")
    plot_bars(ax, np.array(ind1), pacbio_recalls_NA24385,color='#2200ff')
    plot_bars(ax, np.array(ind2), illumina_recalls_NA24385,color='#ff1900')
    plot_bars(ax, np.array(ind3), pacbio_recalls_NA12878,color='#2200ff')
    plot_bars(ax, np.array(ind4), illumina_recalls_NA12878,color='#ff1900')
    prettify_plot()
    ax.set_xticks(np.array(ind1+ind2+ind3+ind4)+1.0*width)
    ax.set_xticklabels(['20','30','40','50','69','30','30','44','30'])

    #ax.set_yscale('log')NA12878_prec_recall_{chrom}
    #plt.xlim(())
    #plt.ylim((0,1.0))
    #plt.legend(loc='upper left')
    plt.xlabel(" ",labelpad=10)

    plt.tight_layout()
    plt.subplots_adjust(top=0.90)
    #t = plt.suptitle(title)

    ax.set_axisbelow(True)

    ticklabelpad = mpl.rcParams['xtick.major.pad']

    ax.annotate('coverage', xy=(-0.1,-0.03), xytext=(5, -ticklabelpad), ha='left', va='top',
                xycoords='axes fraction', textcoords='offset points')
    ax.annotate('NA24385', xy=(0.27,-0.15), xytext=(5, -ticklabelpad), ha='left', va='top',
                xycoords='axes fraction', textcoords='offset points')
    ax.annotate('NA12878', xy=(0.77,-0.15), xytext=(5, -ticklabelpad), ha='left', va='top',
                xycoords='axes fraction', textcoords='offset points')

    # credit to https://stackoverflow.com/questions/4700614/how-to-put-the-legend-out-of-the-plot
    # Shrink current axis by 20%
    box = ax.get_position()
    #ax.set_position([box.x0, box.y0, box.width * 0.85, box.height])
    # Put a legend to the right of the current axis
    #ax.legend(loc='center left', bbox_to_anchor=(1, 0.5))

    #plt.show()
    plt.savefig(output_file)




def plot_precision_recall_bars_NA12878_NA24385_with_haplotypefree(hap_dirlist_NA24385, nohap_dirlist_NA24385,
                                               hap_dirlist_NA12878, nohap_dirlist_NA12878,
                                               gq_cutoffs_NA24385, gq_cutoffs_NA12878, output_file):

    plt.figure(figsize=(7,5))
    #mpl.rcParams['axes.titlepad'] = 50

    width = 0.05
    alpha1 = 0.6

    def plot_bars(ax, ind, vals1, vals2, lab1=None, lab2=None):

        plt.bar(ind+width, vals1, color='#2200ff',
                ecolor='black', # black error bar color
                alpha=alpha1,      # transparency
                width=width,      # smaller bar width
                align='center',
                label=lab1)
        plt.bar(ind+2*width, vals2, color='k',
                ecolor='black', # black error bar color
                alpha=alpha1,      # transparency
                width=width,      # smaller bar width
                align='center',
                label=lab2)

    def prettify_plot():

        ax.yaxis.grid(True,color='grey', alpha=0.5, linestyle='--')
        ax.spines["top"].set_visible(False)
        ax.spines["right"].set_visible(False)
        ax.spines["bottom"].set_visible(False)
        ax.spines["left"].set_visible(False)
        plt.tick_params(axis="both", which="both", bottom=False, top=False,
                    labelbottom=True, left=False, right=False, labelleft=True)


    ind1 = [0,0.15,0.3,0.45,0.6]
    ind2 = [0.9,1.05]

    hap_precisions_NA24385, hap_recalls_NA24385 = zip(*[get_precision_recall(d, g) for d,g in zip(hap_dirlist_NA24385, gq_cutoffs_NA24385)])
    nohap_precisions_NA24385, nohap_recalls_NA24385 = zip(*[get_precision_recall(d, g) for d,g in zip(nohap_dirlist_NA24385, gq_cutoffs_NA24385)])
    hap_precisions_NA12878, hap_recalls_NA12878 = zip(*[get_precision_recall(d, g) for d,g in zip(hap_dirlist_NA12878,gq_cutoffs_NA12878)])
    nohap_precisions_NA12878, nohap_recalls_NA12878 = zip(*[get_precision_recall(d, g) for d,g in zip(nohap_dirlist_NA12878,gq_cutoffs_NA12878)])

    ax = plt.subplot(211)
    plot_bars(ax, np.array(ind1), hap_precisions_NA24385, nohap_precisions_NA24385, lab1='With haplotype assembly', lab2='Without haplotype assembly')
    plot_bars(ax, np.array(ind2), hap_precisions_NA12878, nohap_precisions_NA12878)
    ax.legend(loc='center left', bbox_to_anchor=(0.25,1.13),ncol=2)

    plt.ylabel("Precision")
    plt.ylim(0.95,1.0)
    prettify_plot()
    ax.set_xticks([])
    ax.set_xticklabels([])

    ax = plt.subplot(212)
    plt.ylabel("Recall\n")
    plot_bars(ax, np.array(ind1), hap_recalls_NA24385, nohap_recalls_NA24385, lab1='With haplotype assembly', lab2='Without haplotype assembly')
    plot_bars(ax, np.array(ind2), hap_recalls_NA12878, nohap_recalls_NA12878)
    prettify_plot()
    ax.set_xticks(np.array(ind1+ind2)+1.5*width)
    ax.set_xticklabels(['20','30','40','50','69','30','44'])

    #ax.set_yscale('log')NA12878_prec_recall_{chrom}
    #plt.xlim(())
    #plt.ylim((0,1.0))
    #plt.legend(loc='upper left')
    plt.xlabel(" ",labelpad=10)

    plt.tight_layout()
    plt.subplots_adjust(top=0.90)
    #t = plt.suptitle(title)

    ax.set_axisbelow(True)

    ticklabelpad = mpl.rcParams['xtick.major.pad']

    ax.annotate('coverage', xy=(-0.1,-0.03), xytext=(5, -ticklabelpad), ha='left', va='top',
                xycoords='axes fraction', textcoords='offset points')
    ax.annotate('NA24385', xy=(0.23,-0.15), xytext=(5, -ticklabelpad), ha='left', va='top',
                xycoords='axes fraction', textcoords='offset points')
    ax.annotate('NA12878', xy=(0.7,-0.15), xytext=(5, -ticklabelpad), ha='left', va='top',
                xycoords='axes fraction', textcoords='offset points')

    # credit to https://stackoverflow.com/questions/4700614/how-to-put-the-legend-out-of-the-plot
    # Shrink current axis by 20%
    box = ax.get_position()
    #ax.set_position([box.x0, box.y0, box.width * 0.85, box.height])
    # Put a legend to the right of the current axis
    #ax.legend(loc='center left', bbox_to_anchor=(1, 0.5))

    #plt.show()
    plt.savefig(output_file)



genomes_table_files = namedtuple('genomes_table_files', ['vcfeval_dir', 'vcfstats_genome', 'vcfstats_outside_GIAB', 'runtime'])
genomes_table_entry = namedtuple('genomes_table_entry', ['SNVs_called', 'precision', 'recall', 'outside_GIAB', 'runtime'])

def get_snp_count(vcfstats_file):
    snps_re = re.compile("\nSNPs\s+: (\d+)\n")
    with open(vcfstats_file,'r') as inf:
        fstr = inf.read()
        return int(snps_re.findall(fstr)[0])

def get_TsTv(vcfstats_file):
    tstv_re = re.compile("\nSNP Transitions/Transversions: (\d+\.\d+)\s+")
    with open(vcfstats_file,'r') as inf:
        fstr = inf.read()
        return float(tstv_re.findall(fstr)[0])

def make_table_4_genomes(NA12878_table_files, NA24385_table_files,
                         NA24149_table_files, NA24143_table_files,
                         gq_cutoff, outfile):

    def generate_table_line(table_files):

        precision, recall = get_precision_recall(table_files.vcfeval_dir, gq_cutoff)
        with open(table_files.runtime,'r') as inf:
            hh, mm, ss = inf.readline().strip().split(':')
        runtime = hh + ':' + mm

        snvs_total = get_snp_count(table_files.vcfstats_genome)
        snvs_outside_giab = get_snp_count(table_files.vcfstats_outside_GIAB)

        return genomes_table_entry(SNVs_called=snvs_total, precision=precision, recall=recall,
                                   outside_GIAB=snvs_outside_giab, runtime=runtime)

    NA12878 = generate_table_line(NA12878_table_files)
    NA24385 = generate_table_line(NA24385_table_files)
    NA24149 = generate_table_line(NA24149_table_files)
    NA24143 = generate_table_line(NA24143_table_files)

    s = '''
\\begin{{table}}[htbp]
\\centering
\\begin{{tabular}}{{lllllll}}
\\hline
Genome      & Read & SNVs    & Precision     & Recall    & Outside GIAB  & Run time  \\\\
            & Coverage & called    &    &  & high-confidence       & (hours)          \\\\
\\hline
NA12878   & $44\\times$ & ${}$ & ${:.3f}$ & ${:.3f}$ & ${}$ & {} \\\\
NA24385 (AJ son) & $69\\times$ & ${}$ & ${:.3f}$ & ${:.3f}$ & ${}$ & {} \\\\
NA24149 (AJ father) & $32\\times$ & ${}$ & ${:.3f}$ & ${:.3f}$ & ${}$ & {} \\\\
NA24143 (AJ mother) & $30\\times$ & ${}$ & ${:.3f}$ & ${:.3f}$ & ${}$ & {} \\\\
# \\hline
\\end{{tabular}}
\\caption{{{{\\bf Summary of variants called on GIAB genomes.}}}}
\\label{{tab:stats}}
\\end{{table}}
'''.format(NA12878.SNVs_called, NA12878.precision, NA12878.recall, NA12878.outside_GIAB, NA12878.runtime,
           NA24385.SNVs_called, NA24385.precision, NA24385.recall, NA24385.outside_GIAB, NA24385.runtime,
           NA24149.SNVs_called, NA24149.precision, NA24149.recall, NA24149.outside_GIAB, NA24149.runtime,
           NA24143.SNVs_called, NA24143.precision, NA24143.recall, NA24143.outside_GIAB, NA24143.runtime)

    with open(outfile,'w') as outf:
        print(s, file=outf)

def make_table_4_genomes_extended(NA12878_30x_table_files, NA12878_44x_table_files,
                                  NA24385_20x_table_files, NA24385_30x_table_files,
                                  NA24385_40x_table_files, NA24385_50x_table_files,
                                  NA24385_69x_table_files,
                                  NA24149_32x_table_files,
                                  NA24143_30x_table_files,
                                  gq_cutoff, outfile):

    def generate_table_line(table_files):

        precision, recall = get_precision_recall(table_files.vcfeval_dir, gq_cutoff)
        with open(table_files.runtime,'r') as inf:
            hh, mm, ss = inf.readline().strip().split(':')
        runtime = hh + ':' + mm

        snvs_total = get_snp_count(table_files.vcfstats_genome)
        snvs_outside_giab = get_snp_count(table_files.vcfstats_outside_GIAB)

        return genomes_table_entry(SNVs_called=snvs_total, precision=precision, recall=recall,
                                   outside_GIAB=snvs_outside_giab, runtime=runtime)

    NA12878_30x = generate_table_line(NA12878_30x_table_files)
    NA12878_44x = generate_table_line(NA12878_44x_table_files)

    NA24385_20x = generate_table_line(NA24385_20x_table_files)
    NA24385_30x = generate_table_line(NA24385_30x_table_files)
    NA24385_40x = generate_table_line(NA24385_40x_table_files)
    NA24385_50x = generate_table_line(NA24385_50x_table_files)
    NA24385_69x = generate_table_line(NA24385_69x_table_files)

    NA24149_32x = generate_table_line(NA24149_32x_table_files)
    NA24143_30x = generate_table_line(NA24143_30x_table_files)

    s = '''
\\begin{{table}}[htbp]
\\centering
\\begin{{tabular}}{{lllllll}}
\\hline
Genome      & Read & SNVs    & Precision     & Recall    & Outside GIAB  & Run time  \\\\
            & Coverage & called    &    &  & high-confidence       & (hours)          \\\\
\\hline
NA12878   & $30\\times$ & {} & ${:.3f}$ & ${:.3f}$ & ${}$ & {} \\\\
NA12878   & $44\\times$ & {} & ${:.3f}$ & ${:.3f}$ & ${}$ & {} \\\\
NA24385 (AJ son) & $20\\times$ & ${}$ & ${:.3f}$ & ${:.3f}$ & ${}$ & {} \\\\
NA24385 (AJ son) & $30\\times$ & ${}$ & ${:.3f}$ & ${:.3f}$ & ${}$ & {} \\\\
NA24385 (AJ son) & $40\\times$ & ${}$ & ${:.3f}$ & ${:.3f}$ & ${}$ & {} \\\\
NA24385 (AJ son) & $50\\times$ & ${}$ & ${:.3f}$ & ${:.3f}$ & ${}$ & {} \\\\
NA24385 (AJ son) & $69\\times$ & ${}$ & ${:.3f}$ & ${:.3f}$ & ${}$ & {} \\\\
NA24149 (AJ father) & $32\\times$ & ${}$ & ${:.3f}$ & ${:.3f}$ & ${}$ & {} \\\\
NA24143 (AJ mother) & $30\\times$ & ${}$ & ${:.3f}$ & ${:.3f}$ & ${}$ & {} \\\\
\\hline
\\end{{tabular}}
\\caption{{{{\\bf Summary of variants called on GIAB genomes.}}}}
\\label{{tab:stats}}
\\end{{table}}
'''.format(NA12878_30x.SNVs_called, NA12878_30x.precision, NA12878_30x.recall, NA12878_30x.outside_GIAB, NA12878_30x.runtime,
           NA12878_44x.SNVs_called, NA12878_44x.precision, NA12878_44x.recall, NA12878_44x.outside_GIAB, NA12878_44x.runtime,
           NA24385_20x.SNVs_called, NA24385_20x.precision, NA24385_20x.recall, NA24385_20x.outside_GIAB, NA24385_20x.runtime,
           NA24385_30x.SNVs_called, NA24385_30x.precision, NA24385_30x.recall, NA24385_30x.outside_GIAB, NA24385_30x.runtime,
           NA24385_40x.SNVs_called, NA24385_40x.precision, NA24385_40x.recall, NA24385_40x.outside_GIAB, NA24385_40x.runtime,
           NA24385_50x.SNVs_called, NA24385_50x.precision, NA24385_50x.recall, NA24385_50x.outside_GIAB, NA24385_50x.runtime,
           NA24385_69x.SNVs_called, NA24385_69x.precision, NA24385_69x.recall, NA24385_69x.outside_GIAB, NA24385_69x.runtime,
           NA24149_32x.SNVs_called, NA24149_32x.precision, NA24149_32x.recall, NA24149_32x.outside_GIAB, NA24149_32x.runtime,
           NA24143_30x.SNVs_called, NA24143_30x.precision, NA24143_30x.recall, NA24143_30x.outside_GIAB, NA24143_30x.runtime)

    with open(outfile,'w') as outf:
        print(s, file=outf)

MAX_DEPTH = 50
def plot_depth_of_mapped_vs_breadth(inputs, labels, colors, output_file):

    plt.figure(figsize=(6,6))
    ax = plt.subplot(111)

    def get_depth_breadth(histogram_file):
        breadth = defaultdict(int)
        chr_sizes = dict()
        with open(histogram_file,'r') as infile:
            for line in infile:
                el = line.strip().split('\t')

                chrom = el[0]
                depth = int(el[1])
                num_bases = int(el[2])
                chr_size = int(el[3])
                if chrom in chr_sizes:
                    assert(chr_sizes[chrom] == chr_size)
                else:
                    chr_sizes[chrom] = chr_size

                if depth > MAX_DEPTH:
                    depth = MAX_DEPTH
                breadth[depth] += num_bases

        # cumulative breadth
        cml_breadth = defaultdict(int)

        # sorted (depth, breadth) pairs
        s_breadth = sorted(list(breadth.items()))

        for d, b in s_breadth:
            for d2,b2 in s_breadth:
                if d2 >= d:
                    cml_breadth[d] += b2

        d_val = []
        b_frac = []
        genome_len = sum(chr_sizes.values())*1.0
        # sorted cumulative breadth
        for d in range(0,51):
            d_val.append(d)
            b_frac.append(cml_breadth[d]/genome_len)
        #for d, b in sorted(list(cml_breadth.items())):
        #    d_val.append(d)
        #    b_frac.append(b/genome_len)

        return d_val, b_frac

    for input,label,color in zip(inputs, labels, colors):
        #if 'mapq0' not in input and 'mapq30' not in input:
        #    continue
        d_val, b_frac = get_depth_breadth(input)
        print(label + ':')
        print("depth\tbreadth")
        for d,b in zip(d_val, b_frac):
            print("{}\t{}".format(d, b))
        print("")
        plt.plot(d_val,b_frac,color=color,label=label)

    plt.grid(True,color='grey',linestyle='--',alpha=0.5)

    ax.spines["top"].set_visible(False)
    ax.spines["right"].set_visible(False)
    ax.spines["bottom"].set_visible(False)
    ax.spines["left"].set_visible(False)
    plt.tick_params(axis="both", which="both", bottom="off", top="off",
                labelbottom="on", left="off", right="off", labelleft="on")

    plt.xlabel('Recall')
    plt.ylabel('Precision')

    plt.legend(loc='lower left')
    plt.xlabel('Minimum Depth of Mapped Reads')
    plt.ylabel('Fraction of Genome Covered')
    plt.tight_layout()

    plt.savefig(output_file)


def make_variant_counts_table(illumina_genome_stats,
                              illumina_segdup_stats,
                              illumina_GIAB_confident_stats,
                              illumina_GIAB_nonconfident_stats,
                              pacbio_genome_stats,
                              pacbio_segdup_stats,
                              pacbio_GIAB_confident_stats,
                              pacbio_GIAB_nonconfident_stats,
                              intersect_illumina_pacbio_genome_stats,
                              intersect_illumina_pacbio_segdup_stats,
                              intersect_illumina_pacbio_GIAB_confident_stats,
                              intersect_illumina_pacbio_GIAB_nonconfident_stats,
                              outfile):

    # TsTv and num SNVs for illumina short reads
    illumina_genome_TsTv = get_TsTv(illumina_genome_stats)
    illumina_genome_numSNVs = get_snp_count(illumina_genome_stats)

    illumina_segdup_TsTv = get_TsTv(illumina_segdup_stats)
    illumina_segdup_numSNVs = get_snp_count(illumina_segdup_stats)

    illumina_GIAB_confident_TsTv = get_TsTv(illumina_GIAB_confident_stats)
    illumina_GIAB_confident_numSNVs = get_snp_count(illumina_GIAB_confident_stats)

    illumina_GIAB_nonconfident_TsTv = get_TsTv(illumina_GIAB_nonconfident_stats)
    illumina_GIAB_nonconfident_numSNVs = get_snp_count(illumina_GIAB_nonconfident_stats)


    # TsTv and num SNVs for pacbio long reads
    pacbio_genome_TsTv = get_TsTv(pacbio_genome_stats)
    pacbio_genome_numSNVs = get_snp_count(pacbio_genome_stats)

    pacbio_segdup_TsTv = get_TsTv(pacbio_segdup_stats)
    pacbio_segdup_numSNVs = get_snp_count(pacbio_segdup_stats)

    pacbio_GIAB_confident_TsTv = get_TsTv(pacbio_GIAB_confident_stats)
    pacbio_GIAB_confident_numSNVs = get_snp_count(pacbio_GIAB_confident_stats)

    pacbio_GIAB_nonconfident_TsTv = get_TsTv(pacbio_GIAB_nonconfident_stats)
    pacbio_GIAB_nonconfident_numSNVs = get_snp_count(pacbio_GIAB_nonconfident_stats)


    # TsTv and num SNVs for intersection of illumina and pacbio long reads
    intersect_illumina_pacbio_genome_TsTv = get_TsTv(intersect_illumina_pacbio_genome_stats)
    intersect_illumina_pacbio_genome_numSNVs = get_snp_count(intersect_illumina_pacbio_genome_stats)

    intersect_illumina_pacbio_segdup_TsTv = get_TsTv(intersect_illumina_pacbio_segdup_stats)
    intersect_illumina_pacbio_segdup_numSNVs = get_snp_count(intersect_illumina_pacbio_segdup_stats)

    intersect_illumina_pacbio_GIAB_confident_TsTv = get_TsTv(intersect_illumina_pacbio_GIAB_confident_stats)
    intersect_illumina_pacbio_GIAB_confident_numSNVs = get_snp_count(intersect_illumina_pacbio_GIAB_confident_stats)

    intersect_illumina_pacbio_GIAB_nonconfident_TsTv = get_TsTv(intersect_illumina_pacbio_GIAB_nonconfident_stats)
    intersect_illumina_pacbio_GIAB_nonconfident_numSNVs = get_snp_count(intersect_illumina_pacbio_GIAB_nonconfident_stats)

    s = '''
\\begin{{table}}[htbp]
\\centering
\\begin{{tabular}}{{lllll}}
\\hline
                                & Genome & Segmental    & Inside GIAB       & Outside GIAB      \\\\
                                & (1-22) & Duplications & Confident Regions & Confident Regions \\\\
\\hline
 # SNVs, Illumina               & {}     & {}           & {}                & {}                \\\\
 Ts/Tv,  Illumina               & {}     & {}           & {}                & {}                \\\\
 # SNVs, PacBio                 & {}     & {}           & {}                & {}                \\\\
 Ts/Tv,  PacBio                 & {}     & {}           & {}                & {}                \\\\
 # SNVs, Illumina $\cap$ PacBio & {}     & {}           & {}                & {}                \\\\
 Ts/Tv,  Illumina $\cap$ PacBio & {}     & {}           & {}                & {}                \\\\
\\hline
\\end{{tabular}}
\\caption{{{{\\bf Number of variants called in various genomic regions with short reads, long reads,
and their intersection.}}}}
\\label{{tab:stats}}
\\end{{table}}
'''.format(illumina_genome_numSNVs, illumina_segdup_numSNVs, illumina_GIAB_confident_numSNVs, illumina_GIAB_nonconfident_numSNVs,
           illumina_genome_TsTv, illumina_segdup_TsTv, illumina_GIAB_confident_TsTv, illumina_GIAB_nonconfident_TsTv,
           pacbio_genome_numSNVs, pacbio_segdup_numSNVs, pacbio_GIAB_confident_numSNVs, pacbio_GIAB_nonconfident_numSNVs,
           pacbio_genome_TsTv, pacbio_segdup_TsTv, pacbio_GIAB_confident_TsTv, pacbio_GIAB_nonconfident_TsTv,
           intersect_illumina_pacbio_genome_numSNVs, intersect_illumina_pacbio_segdup_numSNVs, intersect_illumina_pacbio_GIAB_confident_numSNVs, intersect_illumina_pacbio_GIAB_nonconfident_numSNVs,
           intersect_illumina_pacbio_genome_TsTv, intersect_illumina_pacbio_segdup_TsTv, intersect_illumina_pacbio_GIAB_confident_TsTv, intersect_illumina_pacbio_GIAB_nonconfident_TsTv)

    with open(outfile,'w') as outf:
        print(s, file=outf)


if __name__ == '__main__':
    args = parseargs()
    plot_vcfeval(args.input_dirs, args.labels, args.output_file, args.title)
