import matplotlib as mpl
mpl.use('Agg')
from matplotlib import pyplot as plt
import pickle
import os
import gzip
import argparse


mpl.rc('legend', fontsize=9)
mpl.rc('xtick', labelsize=9)
mpl.rc('ytick', labelsize=9)
mpl.rc('axes', labelsize=9)
mpl.rc('axes', labelsize=9)
mpl.rcParams.update({'font.size': 9})
mpl.rc('lines', linewidth=1.5)
mpl.rc('mathtext',default='regular')
'''
def parseargs():

    parser = argparse.ArgumentParser(description='this tool is meant to make precision-recall curves from RTGtools vcfeval data, that are prettier than those from RTGtools rocplot function.')
    parser.add_argument('-i', '--input_dirs', nargs='+', type = str, help='list of directories generated by RTGtools vcfeval tool', default=None)
    parser.add_argument('-l', '--labels', nargs='+', type = str, help='list of labels to associate to input_dirs', default=None)
    parser.add_argument('-o', '--output_file', nargs='?', type = str, help='PNG file to write plot to.', default=None)
    parser.add_argument('-t', '--title', nargs='?', type = str, help='title for plot', default=None)

    args = parser.parse_args()
    return args
'''
# input:
# vcfeval_dir: directory containing vcfeval output
# gq_cutoff: a Genotype Quality value to set as the cutoff for variants e.g. 30 or 50
# output:
# (precision, recall) : the precision and recall values for variants above the GQ cutoff
def get_precision_recall(vcfeval_dir, gq_cutoff):

    total_baseline = None
    score = []
    recall = None
    precision = None
    qual = None

    with gzip.open(os.path.join(path,'snp_roc.tsv.gz'),mode='rt') as inf:

        for line in inf:
            if line[0] == '#':
                if '#total baseline variants:' in line:
                    total_baseline = float(line.strip().split()[3])
                continue
            else:
                el = [float(x) for x in line.strip().split()]
                assert(len(el) == 4)

                score.append(el[0])

                new_qual = float(el[0])
                TPb = el[1]
                TPc = el[3]
                FN = total_baseline - el[1]
                FP = el[2]

                if new_qual < gq_cutoff:
                    break

                qual = new_qual
                precision = TPc/(TPc+FP)
                recall = TPb/(TPb+FN)

    # this should be true for large enough datasets, like we will look at,
    # and it's a nice sanity check
    assert(qual - gq_cutoff >= 0)
    assert(qual - gq_cutoff < 1.0)
    assert(precision != None)
    assert(recall != None)

    return (precision, recall)

def plot_precision_recall_bars(dirlist, gq_cutoff, labels, output_file, title):

    IND = np.array([0,1,2,3,4,5])  # the x locations for the groups

    precisions, recalls = zip(*[get_precision_recall(d, gq_cutoff) for d in dirlist])
    ind = np.array([0,0.5,1,1.5,2,2.5]) # the x locations for the groups
    width = 0.04
    alpha1 = 0.8

    plt.bar(ind+width, precisions, color='k',
            ecolor='black', # black error bar color
            alpha=alpha1,      # transparency
            width=width,      # smaller bar width
            align='center',
            label='Precision')
    plt.bar(ind+2*width, recalls, color='grey',
            ecolor='black', # black error bar color
            alpha=alpha1,      # transparency
            width=width,      # smaller bar width
            align='center',
           label='Recall')

    # add some text for labels, title and axes ticks
    #plt.xlim(-0.5,6)

    #ax.set_ylabel('Error Rate')
    ax.set_xticks(IND+1.5*width)
    ax.set_xticklabels(labels)

    #plt.xlim(())
    #plt.ylim(ylim)
    plt.xlabel('Recall')
    plt.ylabel('Precision')
    plt.legend(loc='upper left')
    plt.tight_layout()
    ax1.set_axisbelow(True)
    plt.savefig(output_file)

if __name__ == '__main__':
    args = parseargs()
    plot_vcfeval(args.input_dirs, args.labels, args.output_file, args.title)
